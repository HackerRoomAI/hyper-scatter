{"version":3,"file":"main-CKkTA75B.js","sources":["../../src/core/rng.ts","../../src/core/dataset.ts","../../src/core/types.ts","../../src/core/math/euclidean.ts","../../src/core/selection/point_in_polygon.ts","../../src/impl_reference/euclidean_reference.ts","../../src/core/math/poincare.ts","../../src/impl_reference/hyperbolic_reference.ts","../../src/impl_candidate/spatial_index.ts","../../src/impl_candidate/webgl_candidate.ts","../../src/core/lasso_simplify.ts","../../src/ui/app.ts"],"sourcesContent":["/**\n * Seeded pseudo-random number generator for deterministic datasets.\n * Uses a simple xoshiro128** algorithm.\n */\n\nexport class SeededRNG {\n  private state: Uint32Array;\n\n  constructor(seed: number) {\n    // Initialize state from seed using splitmix64\n    this.state = new Uint32Array(4);\n    let s = seed >>> 0;\n    for (let i = 0; i < 4; i++) {\n      s = (s + 0x9e3779b9) >>> 0;\n      let z = s;\n      z = ((z ^ (z >>> 16)) * 0x85ebca6b) >>> 0;\n      z = ((z ^ (z >>> 13)) * 0xc2b2ae35) >>> 0;\n      z = (z ^ (z >>> 16)) >>> 0;\n      this.state[i] = z;\n    }\n  }\n\n  /** Returns a float in [0, 1) */\n  random(): number {\n    const result = this.rotl(this.state[1] * 5, 7) * 9;\n    const t = this.state[1] << 9;\n\n    this.state[2] ^= this.state[0];\n    this.state[3] ^= this.state[1];\n    this.state[1] ^= this.state[2];\n    this.state[0] ^= this.state[3];\n    this.state[2] ^= t;\n    this.state[3] = this.rotl(this.state[3], 11);\n\n    return (result >>> 0) / 0x100000000;\n  }\n\n  /** Returns a float in [min, max) */\n  range(min: number, max: number): number {\n    return min + this.random() * (max - min);\n  }\n\n  /** Returns an integer in [0, max) */\n  int(max: number): number {\n    return Math.floor(this.random() * max);\n  }\n\n  /** Returns a normally distributed value (Box-Muller) */\n  gaussian(mean = 0, std = 1): number {\n    // Clamp u1 away from 0 to avoid log(0) = -Infinity\n    const u1 = Math.max(this.random(), 1e-10);\n    const u2 = this.random();\n    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    return mean + z * std;\n  }\n\n  private rotl(x: number, k: number): number {\n    return ((x << k) | (x >>> (32 - k))) >>> 0;\n  }\n}\n","/**\n * Deterministic dataset generation for testing.\n */\n\nimport { Dataset, GeometryMode } from './types.js';\nimport { SeededRNG } from './rng.js';\n\nexport interface DatasetConfig {\n  seed: number;\n  n: number;\n  labelCount: number;\n  geometry: GeometryMode;\n  /** Controls the spatial distribution of generated points. */\n  distribution?: DatasetDistribution;\n  /** For hyperbolic: generate points near boundary (stress test) */\n  boundaryStress?: boolean;\n}\n\nexport type DatasetDistribution =\n  | 'default'\n  | 'clustered';\n\n// For very large-N benchmarks we want determinism but also *reasonable* setup time.\n// Dataset generation is not the performance target of this project; rendering and\n// interaction are. For N in the multi-millions, avoid per-point trig/log-heavy\n// sampling where possible.\nconst FAST_PATH_THRESHOLD_N = 2_000_000;\n\nfunction gaussianFastApprox(rng: SeededRNG, mean = 0, std = 1): number {\n  // Irwin–Hall approximation: sum of uniforms approximates a normal.\n  // Using 6 uniforms is a good speed/quality tradeoff.\n  // Output has mean 0, variance 0.5 -> std ~0.707; we rescale to unit std.\n  const u =\n    rng.random() + rng.random() + rng.random() +\n    rng.random() + rng.random() + rng.random();\n  const z = (u - 3.0) * 1.4142135623730951; // sqrt(2)\n  return mean + z * std;\n}\n\nfunction fillPoincareClusterCentersRandom(\n  rng: SeededRNG,\n  labelCount: number,\n  outCx: Float32Array,\n  outCy: Float32Array,\n  outJitterStd: Float32Array,\n): void {\n  // Random cluster centers inside disk with area-uniform radius.\n  // We still scale jitter by (1-|center|^2)/2 to keep clusters visually\n  // comparable in hyperbolic units.\n  const hyperbolicStd = 0.30;\n\n  for (let label = 0; label < labelCount; label++) {\n    const r = Math.sqrt(rng.random()) * 0.92;\n    const theta = rng.range(0, 2 * Math.PI);\n    const cx = r * Math.cos(theta);\n    const cy = r * Math.sin(theta);\n    outCx[label] = cx;\n    outCy[label] = cy;\n    const r2 = cx * cx + cy * cy;\n    outJitterStd[label] = hyperbolicStd * 0.5 * (1 - r2);\n  }\n}\n\n/**\n * Generate a deterministic dataset.\n */\nexport function generateDataset(config: DatasetConfig): Dataset {\n  const rng = new SeededRNG(config.seed);\n  const positions = new Float32Array(config.n * 2);\n  const labels = new Uint16Array(config.n);\n\n  const fast = config.n >= FAST_PATH_THRESHOLD_N;\n\n  const distribution: DatasetDistribution = config.distribution ?? 'default';\n\n  if (config.geometry === 'euclidean') {\n    // Generate clustered Euclidean data\n    const clusterCenters: Array<{ x: number; y: number }> = [];\n    for (let i = 0; i < config.labelCount; i++) {\n      clusterCenters.push({\n        x: rng.range(-1, 1),\n        y: rng.range(-1, 1),\n      });\n    }\n\n    for (let i = 0; i < config.n; i++) {\n      const label = rng.int(config.labelCount);\n      const center = clusterCenters[label];\n\n      // For huge N, avoid Box–Muller (log/cos/sqrt) per point.\n      // The approximation keeps overall visual structure and determinism.\n      const noiseX = fast ? gaussianFastApprox(rng, 0, 0.15) : rng.gaussian(0, 0.15);\n      const noiseY = fast ? gaussianFastApprox(rng, 0, 0.15) : rng.gaussian(0, 0.15);\n      positions[i * 2] = center.x + noiseX;\n      positions[i * 2 + 1] = center.y + noiseY;\n      labels[i] = label;\n    }\n  } else {\n    // Generate Poincare disk data\n    // Points must be inside the unit disk (|z| < 1)\n\n    if (distribution === 'clustered') {\n      const cx = new Float32Array(config.labelCount);\n      const cy = new Float32Array(config.labelCount);\n      const jitterStd = new Float32Array(config.labelCount);\n      fillPoincareClusterCentersRandom(rng, config.labelCount, cx, cy, jitterStd);\n\n      for (let i = 0; i < config.n; i++) {\n        const label = rng.int(config.labelCount);\n        const j = jitterStd[label];\n        const noiseX = fast ? gaussianFastApprox(rng, 0, j) : rng.gaussian(0, j);\n        const noiseY = fast ? gaussianFastApprox(rng, 0, j) : rng.gaussian(0, j);\n\n        let x = cx[label] + noiseX;\n        let y = cy[label] + noiseY;\n        const rSq = x * x + y * y;\n        if (rSq >= 1) {\n          const invR = 0.999 / Math.sqrt(rSq);\n          x *= invR;\n          y *= invR;\n        }\n\n        positions[i * 2] = x;\n        positions[i * 2 + 1] = y;\n        labels[i] = label;\n      }\n\n      return {\n        n: config.n,\n        positions,\n        labels,\n        geometry: config.geometry,\n      };\n    }\n\n    // For huge N, avoid sin/cos per point by sampling angle from a lookup table.\n    // Deterministic (seeded) and close enough for stress/perf testing.\n    const tableSize = fast ? 4096 : 0;\n    const cosTable = tableSize ? new Float32Array(tableSize) : null;\n    const sinTable = tableSize ? new Float32Array(tableSize) : null;\n    if (tableSize && cosTable && sinTable) {\n      for (let t = 0; t < tableSize; t++) {\n        const theta = (t / tableSize) * 2 * Math.PI;\n        cosTable[t] = Math.cos(theta);\n        sinTable[t] = Math.sin(theta);\n      }\n    }\n\n    for (let i = 0; i < config.n; i++) {\n      const label = rng.int(config.labelCount);\n      let r: number;\n\n      if (config.boundaryStress) {\n        // Stress test: many points near boundary\n        r = rng.range(0.9, 0.999);\n      } else {\n        // Normal distribution: use sqrt for uniform area distribution\n        // Then compress slightly to avoid exact boundary\n        r = Math.sqrt(rng.random()) * 0.95;\n      }\n\n      if (tableSize && cosTable && sinTable) {\n        const t = rng.int(tableSize);\n        positions[i * 2] = r * cosTable[t];\n        positions[i * 2 + 1] = r * sinTable[t];\n      } else {\n        const theta = rng.range(0, 2 * Math.PI);\n        positions[i * 2] = r * Math.cos(theta);\n        positions[i * 2 + 1] = r * Math.sin(theta);\n      }\n      labels[i] = label;\n    }\n  }\n\n  return {\n    n: config.n,\n    positions,\n    labels,\n    geometry: config.geometry,\n  };\n}\n\n/**\n * Standard test datasets.\n */\nexport const STANDARD_DATASETS = {\n  euclidean_10k: { seed: 42, n: 10_000, labelCount: 10, geometry: 'euclidean' as const },\n  euclidean_100k: { seed: 42, n: 100_000, labelCount: 10, geometry: 'euclidean' as const },\n  euclidean_1m: { seed: 42, n: 1_000_000, labelCount: 10, geometry: 'euclidean' as const },\n  poincare_10k: { seed: 42, n: 10_000, labelCount: 10, geometry: 'poincare' as const },\n  poincare_100k: { seed: 42, n: 100_000, labelCount: 10, geometry: 'poincare' as const },\n  poincare_boundary_stress: { seed: 42, n: 100_000, labelCount: 10, geometry: 'poincare' as const, boundaryStress: true },\n};\n","/**\n * Core types and contracts for the viz-lab.\n * Both reference and candidate implementations must satisfy these interfaces.\n */\n\n// ============================================================================\n// Data Types\n// ============================================================================\n\nexport interface Dataset {\n  /** Number of points */\n  n: number;\n  /** Interleaved x,y coordinates: [x0, y0, x1, y1, ...] length = 2*n */\n  positions: Float32Array;\n  /** Label for each point (for coloring) */\n  labels: Uint16Array;\n  /** Geometry mode */\n  geometry: GeometryMode;\n}\n\nexport type GeometryMode = 'euclidean' | 'poincare';\n\n// ============================================================================\n// View State\n// ============================================================================\n\n/** Euclidean view state: simple pan + zoom */\nexport interface EuclideanViewState {\n  type: 'euclidean';\n  /** Center of view in data coordinates */\n  centerX: number;\n  centerY: number;\n  /** Zoom level (1 = no zoom, >1 = zoomed in) */\n  zoom: number;\n}\n\n/**\n * Hyperbolic view state using Mobius transformation.\n * The isometry is represented as translation by a point in the disk.\n * Camera transform: z -> (z - a) / (1 - conj(a) * z) where a = (ax, ay)\n */\nexport interface HyperbolicViewState {\n  type: 'poincare';\n  /** Translation point x-coordinate (in Poincare disk, |a| < 1) */\n  ax: number;\n  /** Translation point y-coordinate */\n  ay: number;\n  /** Display zoom scalar (purely visual, applied after Mobius) */\n  displayZoom: number;\n}\n\nexport type ViewState = EuclideanViewState | HyperbolicViewState;\n\n// ============================================================================\n// Interaction Types\n// ============================================================================\n\nexport interface Modifiers {\n  shift: boolean;\n  ctrl: boolean;\n  alt: boolean;\n  meta: boolean;\n}\n\nexport interface HitResult {\n  index: number;\n  screenX: number;\n  screenY: number;\n  distance: number;\n}\n\n/** Axis-aligned bounds in 2D data coordinates. */\nexport interface Bounds2D {\n  xMin: number;\n  yMin: number;\n  xMax: number;\n  yMax: number;\n}\n\n/**\n * Geometry-based selection shape in data coordinates.\n * Allows implementations to defer index enumeration.\n */\nexport interface SelectionGeometry {\n  type: 'polygon';\n  /** Polygon vertices in data coordinates: [x0, y0, x1, y1, ...] */\n  coords: Float32Array;\n  /** Optional AABB bounds of coords for fast prefiltering (same coordinate space as coords). */\n  bounds?: Bounds2D;\n}\n\n/**\n * Result of a lasso/selection operation.\n *\n * Implementations may return either:\n * - kind: 'indices' with a Set<number> of selected point indices\n * - kind: 'geometry' with the selection shape in data coordinates\n *\n * Both kinds must provide a has() method for membership testing.\n */\nexport interface SelectionResult {\n  /** How the selection is represented */\n  kind: 'indices' | 'geometry';\n\n  /** For kind === 'indices': the selected point indices */\n  indices?: Set<number>;\n\n  /** For kind === 'geometry': selection shape in data coordinates */\n  geometry?: SelectionGeometry;\n\n  /** Time to compute the selection */\n  computeTimeMs: number;\n\n  /**\n   * Test if a point index is in the selection.\n   * Required for all kinds - enables correctness verification.\n   */\n  has(index: number): boolean;\n}\n\nexport type InteractionMode = 'pan' | 'lasso';\n\n// ============================================================================\n// Renderer Contract\n// ============================================================================\n\nexport interface InitOptions {\n  width: number;\n  height: number;\n  devicePixelRatio?: number;\n  backgroundColor?: string;\n  pointRadius?: number;\n  colors?: string[];\n\n  /** Optional styling overrides for the hyperbolic (Poincaré) disk backdrop. */\n  poincareDiskFillColor?: string;\n  poincareDiskBorderColor?: string;\n  poincareGridColor?: string;\n  poincareDiskBorderWidthPx?: number;\n  poincareGridWidthPx?: number;\n\n}\n\nexport interface Renderer {\n  /** Initialize the renderer with a canvas */\n  init(canvas: HTMLCanvasElement, opts: InitOptions): void;\n\n  /** Set the dataset to render */\n  setDataset(dataset: Dataset): void;\n\n  /** Set the current view state */\n  setView(view: ViewState): void;\n\n  /** Get the current view state */\n  getView(): ViewState;\n\n  /** Render the current frame */\n  render(): void;\n\n  /** Handle canvas resize */\n  resize(width: number, height: number): void;\n\n  /** Set selected point indices */\n  setSelection(indices: Set<number>): void;\n\n  /** Get current selection */\n  getSelection(): Set<number>;\n\n  /** Set hovered point index (-1 for none) */\n  setHovered(index: number): void;\n\n  /** Clean up resources */\n  destroy(): void;\n\n  // Interaction methods\n\n  /** Pan the view (in screen pixels) */\n  pan(deltaX: number, deltaY: number, modifiers: Modifiers): void;\n\n  /** Zoom at anchor point (wheel delta, positive = zoom in) */\n  zoom(anchorX: number, anchorY: number, delta: number, modifiers: Modifiers): void;\n\n  /** Hit test at screen coordinates */\n  hitTest(screenX: number, screenY: number): HitResult | null;\n\n  /** Lasso selection with screen-space polyline */\n  lassoSelect(polyline: Float32Array): SelectionResult;\n\n  /**\n   * Count the number of points selected by a SelectionResult.\n   *\n   * Motivation: geometry-based (predicate) selections are fast to create, but\n   * naively counting them by scanning all N points in the UI is too slow.\n   * Implementations should use any available spatial index / backend to count\n   * efficiently.\n   */\n  countSelection(result: SelectionResult, opts?: CountSelectionOptions): Promise<number>;\n\n  /** Project a data point to screen coordinates */\n  projectToScreen(dataX: number, dataY: number): { x: number; y: number };\n\n  /** Unproject screen coordinates to data space */\n  unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number };\n}\n\nexport interface CountSelectionOptions {\n  /** Optional cancellation predicate (return true to abort early). */\n  shouldCancel?: () => boolean;\n\n  /** Optional progress callback for long-running counts. */\n  onProgress?: (selectedCount: number, processedCandidates: number) => void;\n\n  /**\n   * Time slice budget (ms). If > 0, counting yields back to the browser after\n   * roughly this amount of work to keep the UI responsive.\n   *\n   * Set to 0 to run synchronously without yielding (useful for benchmarks).\n   * Default: 8ms.\n   */\n  yieldEveryMs?: number;\n}\n\n// ============================================================================\n// Default Colors (categorical palette)\n// ============================================================================\n\nexport const DEFAULT_COLORS = [\n  '#4e79a7', // blue\n  '#f28e2c', // orange\n  '#e15759', // red\n  '#76b7b2', // teal\n  '#59a14f', // green\n  '#edc949', // yellow\n  '#af7aa1', // purple\n  '#ff9da7', // pink\n  '#9c755f', // brown\n  '#bab0ab', // gray\n];\n\nexport const SELECTION_COLOR = '#ff0000';\nexport const HOVER_COLOR = '#ffffff';\n\n// ============================================================================\n// Selection Result Helpers\n// ============================================================================\n\n/**\n * Create a SelectionResult from a Set of indices.\n * Convenience helper for implementations that compute indices directly.\n */\nexport function createIndicesSelectionResult(\n  indices: Set<number>,\n  computeTimeMs: number\n): SelectionResult {\n  return {\n    kind: 'indices',\n    indices,\n    computeTimeMs,\n    has: (index: number) => indices.has(index),\n  };\n}\n\n/**\n * Create a SelectionResult from geometry and a positions array.\n * The has() method tests point membership against the polygon.\n */\nexport function createGeometrySelectionResult(\n  geometry: SelectionGeometry,\n  positions: Float32Array,\n  computeTimeMs: number,\n  pointInPolygonFn: (px: number, py: number, polygon: Float32Array) => boolean\n): SelectionResult {\n  return {\n    kind: 'geometry',\n    geometry,\n    computeTimeMs,\n    has: (index: number) => {\n      const x = positions[index * 2];\n      const y = positions[index * 2 + 1];\n      return pointInPolygonFn(x, y, geometry.coords);\n    },\n  };\n}\n","/**\n * Euclidean geometry utilities.\n */\n\nimport { EuclideanViewState } from '../types.js';\n\n/**\n * Create a default Euclidean view state.\n */\nexport function createEuclideanView(): EuclideanViewState {\n  return {\n    type: 'euclidean',\n    centerX: 0,\n    centerY: 0,\n    zoom: 1,\n  };\n}\n\n/**\n * Project a data point to screen coordinates.\n */\nexport function projectEuclidean(\n  dataX: number,\n  dataY: number,\n  view: EuclideanViewState,\n  width: number,\n  height: number\n): { x: number; y: number } {\n  const scale = Math.min(width, height) * 0.4 * view.zoom;\n  const x = width / 2 + (dataX - view.centerX) * scale;\n  const y = height / 2 - (dataY - view.centerY) * scale; // flip Y\n  return { x, y };\n}\n\n/**\n * Unproject screen coordinates to data space.\n */\nexport function unprojectEuclidean(\n  screenX: number,\n  screenY: number,\n  view: EuclideanViewState,\n  width: number,\n  height: number\n): { x: number; y: number } {\n  const scale = Math.min(width, height) * 0.4 * view.zoom;\n  const x = view.centerX + (screenX - width / 2) / scale;\n  const y = view.centerY - (screenY - height / 2) / scale; // flip Y\n  return { x, y };\n}\n\n/**\n * Apply pan to view (anchor-invariant: point under cursor stays under cursor).\n */\nexport function panEuclidean(\n  view: EuclideanViewState,\n  deltaScreenX: number,\n  deltaScreenY: number,\n  width: number,\n  height: number\n): EuclideanViewState {\n  const scale = Math.min(width, height) * 0.4 * view.zoom;\n  return {\n    ...view,\n    centerX: view.centerX - deltaScreenX / scale,\n    centerY: view.centerY + deltaScreenY / scale, // flip Y\n  };\n}\n\n/**\n * Apply zoom to view (anchor-invariant: point under cursor stays under cursor).\n */\nexport function zoomEuclidean(\n  view: EuclideanViewState,\n  anchorScreenX: number,\n  anchorScreenY: number,\n  delta: number,\n  width: number,\n  height: number\n): EuclideanViewState {\n  // Get data point under anchor before zoom\n  const anchorData = unprojectEuclidean(anchorScreenX, anchorScreenY, view, width, height);\n\n  // Apply zoom (delta > 0 = zoom in)\n  const zoomFactor = Math.pow(1.1, delta);\n  const newZoom = Math.max(0.1, Math.min(100, view.zoom * zoomFactor));\n\n  // Calculate new center so anchor point stays in place\n  const newScale = Math.min(width, height) * 0.4 * newZoom;\n  const newCenterX = anchorData.x - (anchorScreenX - width / 2) / newScale;\n  const newCenterY = anchorData.y + (anchorScreenY - height / 2) / newScale;\n\n  return {\n    ...view,\n    centerX: newCenterX,\n    centerY: newCenterY,\n    zoom: newZoom,\n  };\n}\n","/**\n * Point-in-polygon test using ray casting algorithm.\n * This is the naive, accurate implementation for reference.\n */\n\nimport type { Bounds2D } from '../types.js';\n\n/**\n * Test if a point is inside a polygon using ray casting.\n * Polygon is given as interleaved x,y coordinates.\n *\n * Polygon semantics:\n * - The polygon is implicitly CLOSED (edge from last vertex to first).\n * - Vertex order may be CW or CCW (even-odd rule; winding does not matter).\n * - Boundary rule: points exactly on an edge are considered INSIDE (within tolerance).\n * - Ray crossing uses a half-open y-interval ((yi > py) !== (yj > py)) to avoid double counts.\n *\n * Boundary rule: points exactly on the edge are considered INSIDE.\n */\nexport function pointInPolygon(\n  px: number,\n  py: number,\n  polygon: Float32Array\n): boolean {\n  const n = polygon.length / 2;\n  if (n < 3) return false;\n\n  let inside = false;\n\n  for (let i = 0, j = n - 1; i < n; j = i++) {\n    const xi = polygon[i * 2];\n    const yi = polygon[i * 2 + 1];\n    const xj = polygon[j * 2];\n    const yj = polygon[j * 2 + 1];\n\n    // Check if point is on edge (within tolerance)\n    if (isPointOnSegment(px, py, xi, yi, xj, yj, 1e-9)) {\n      return true; // Boundary counts as inside\n    }\n\n    // Ray casting\n    if ((yi > py) !== (yj > py)) {\n      const xIntersect = ((xj - xi) * (py - yi)) / (yj - yi) + xi;\n      if (px < xIntersect) {\n        inside = !inside;\n      }\n    }\n  }\n\n  return inside;\n}\n\n/**\n * Compute an axis-aligned bounding box (AABB) for an interleaved polygon.\n *\n * Returns a finite bounds object. For empty input, returns all zeros.\n */\nexport function boundsOfPolygon(polygon: Float32Array): Bounds2D {\n  let xMin = Infinity;\n  let yMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n\n  for (let i = 0; i < polygon.length; i += 2) {\n    const x = polygon[i];\n    const y = polygon[i + 1];\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  }\n\n  if (!Number.isFinite(xMin) || !Number.isFinite(yMin) || !Number.isFinite(xMax) || !Number.isFinite(yMax)) {\n    return { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };\n  }\n\n  return { xMin, yMin, xMax, yMax };\n}\n\n/**\n * Check if a point lies on a line segment (within tolerance).\n */\nfunction isPointOnSegment(\n  px: number,\n  py: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  tolerance: number\n): boolean {\n  // Check if point is within bounding box\n  const minX = Math.min(x1, x2) - tolerance;\n  const maxX = Math.max(x1, x2) + tolerance;\n  const minY = Math.min(y1, y2) - tolerance;\n  const maxY = Math.max(y1, y2) + tolerance;\n\n  if (px < minX || px > maxX || py < minY || py > maxY) {\n    return false;\n  }\n\n  // Calculate distance from point to line\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  if (lengthSq < tolerance * tolerance) {\n    // Degenerate segment (point)\n    const dist = Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n    return dist <= tolerance;\n  }\n\n  // Project point onto line\n  const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));\n  const projX = x1 + t * dx;\n  const projY = y1 + t * dy;\n\n  const dist = Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));\n  return dist <= tolerance;\n}\n\n/**\n * Brute-force lasso selection: test all points against polygon.\n * Returns indices of points inside the polygon.\n */\nexport function lassoSelectBruteForce(\n  positions: Float32Array,\n  polygon: Float32Array\n): Set<number> {\n  const result = new Set<number>();\n  const n = positions.length / 2;\n\n  for (let i = 0; i < n; i++) {\n    const x = positions[i * 2];\n    const y = positions[i * 2 + 1];\n    if (pointInPolygon(x, y, polygon)) {\n      result.add(i);\n    }\n  }\n\n  return result;\n}\n","/**\n * Euclidean Reference Implementation\n *\n * This is the naive but accurate Canvas2D implementation.\n * It serves as ground truth for comparison with optimized candidates.\n */\n\nimport {\n  Dataset,\n  Renderer,\n  InitOptions,\n  ViewState,\n  EuclideanViewState,\n  Modifiers,\n  HitResult,\n  SelectionResult,\n  CountSelectionOptions,\n  DEFAULT_COLORS,\n  SELECTION_COLOR,\n  HOVER_COLOR,\n  createIndicesSelectionResult,\n} from '../core/types.js';\nimport {\n  createEuclideanView,\n  projectEuclidean,\n  unprojectEuclidean,\n  panEuclidean,\n  zoomEuclidean,\n} from '../core/math/euclidean.js';\nimport { lassoSelectBruteForce } from '../core/selection/point_in_polygon.js';\n\nexport class EuclideanReference implements Renderer {\n  private canvas!: HTMLCanvasElement;\n  private ctx!: CanvasRenderingContext2D;\n  private width = 0;\n  private height = 0;\n  private dpr = 1;\n\n  private dataset: Dataset | null = null;\n  private view: EuclideanViewState = createEuclideanView();\n  private selection = new Set<number>();\n  private hoveredIndex = -1;\n\n  private pointRadius = 3;\n  private colors = DEFAULT_COLORS;\n  private backgroundColor = '#0a0a0a';\n\n  init(canvas: HTMLCanvasElement, opts: InitOptions): void {\n    this.canvas = canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Failed to get 2D context');\n    this.ctx = ctx;\n\n    this.width = opts.width;\n    this.height = opts.height;\n    this.dpr = opts.devicePixelRatio ?? 1;\n\n    if (opts.backgroundColor) this.backgroundColor = opts.backgroundColor;\n    if (opts.pointRadius) this.pointRadius = opts.pointRadius;\n    if (opts.colors) this.colors = opts.colors;\n\n    // Set canvas size\n    canvas.width = this.width * this.dpr;\n    canvas.height = this.height * this.dpr;\n    canvas.style.width = `${this.width}px`;\n    canvas.style.height = `${this.height}px`;\n\n    // IMPORTANT: reset transform before applying DPR scaling.\n    // Canvas contexts persist their transform across calls to getContext() and\n    // across renderer swaps, so calling scale() repeatedly would accumulate.\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  setDataset(dataset: Dataset): void {\n    if (dataset.geometry !== 'euclidean') {\n      throw new Error('EuclideanReference only supports euclidean geometry');\n    }\n    this.dataset = dataset;\n    this.selection.clear();\n    this.hoveredIndex = -1;\n\n    // Auto-fit view to data\n    this.fitToData();\n  }\n\n  private fitToData(): void {\n    if (!this.dataset || this.dataset.n === 0) return;\n\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n\n    for (let i = 0; i < this.dataset.n; i++) {\n      const x = this.dataset.positions[i * 2];\n      const y = this.dataset.positions[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    // Calculate zoom to fit data with 10% padding\n    const dataWidth = maxX - minX || 1;\n    const dataHeight = maxY - minY || 1;\n    const dataSize = Math.max(dataWidth, dataHeight);\n\n    // The projection formula: screenPos = canvasCenter + (dataPos - viewCenter) * baseScale * zoom\n    // where baseScale = min(width, height) * 0.4\n    // To fit dataSize into canvas with padding: dataSize * baseScale * zoom = canvasSize * 0.8\n    // zoom = (canvasSize * 0.8) / (dataSize * baseScale)\n    // zoom = 0.8 / (dataSize * 0.4) = 2 / dataSize\n    const fitZoom = 2 / dataSize;\n\n    this.view = {\n      type: 'euclidean',\n      centerX: (minX + maxX) / 2,\n      centerY: (minY + maxY) / 2,\n      zoom: Math.max(0.1, Math.min(100, fitZoom)),\n    };\n  }\n\n  setView(view: ViewState): void {\n    if (view.type !== 'euclidean') {\n      throw new Error('EuclideanReference only supports euclidean view state');\n    }\n    this.view = view;\n  }\n\n  getView(): ViewState {\n    return { ...this.view };\n  }\n\n  setSelection(indices: Set<number>): void {\n    this.selection = new Set(indices);\n  }\n\n  getSelection(): Set<number> {\n    return new Set(this.selection);\n  }\n\n  setHovered(index: number): void {\n    this.hoveredIndex = index;\n  }\n\n  render(): void {\n    const { ctx, width, height, dataset, view } = this;\n    if (!dataset) return;\n\n    // Clear background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw all points (naive: no culling, no batching)\n    const { positions, labels, n } = dataset;\n    const radius = this.pointRadius;\n\n    // First pass: unselected points\n    for (let i = 0; i < n; i++) {\n      if (this.selection.has(i) || i === this.hoveredIndex) continue;\n\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectEuclidean(dataX, dataY, view, width, height);\n\n      // Simple frustum culling\n      if (screen.x < -radius || screen.x > width + radius ||\n          screen.y < -radius || screen.y > height + radius) {\n        continue;\n      }\n\n      ctx.fillStyle = this.colors[labels[i] % this.colors.length];\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Second pass: selected points (drawn on top)\n    ctx.fillStyle = SELECTION_COLOR;\n    for (const i of this.selection) {\n      if (i === this.hoveredIndex) continue;\n\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectEuclidean(dataX, dataY, view, width, height);\n\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 1, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Third pass: hovered point (topmost)\n    if (this.hoveredIndex >= 0 && this.hoveredIndex < n) {\n      const i = this.hoveredIndex;\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectEuclidean(dataX, dataY, view, width, height);\n\n      // White ring\n      ctx.strokeStyle = HOVER_COLOR;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 3, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Point color\n      ctx.fillStyle = this.selection.has(i)\n        ? SELECTION_COLOR\n        : this.colors[labels[i] % this.colors.length];\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 1, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  resize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.canvas.width = width * this.dpr;\n    this.canvas.height = height * this.dpr;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  destroy(): void {\n    // Nothing to clean up for Canvas2D\n  }\n\n  // === Interaction Methods ===\n\n  pan(deltaX: number, deltaY: number, _modifiers: Modifiers): void {\n    this.view = panEuclidean(this.view, deltaX, deltaY, this.width, this.height);\n  }\n\n  zoom(anchorX: number, anchorY: number, delta: number, _modifiers: Modifiers): void {\n    this.view = zoomEuclidean(this.view, anchorX, anchorY, delta, this.width, this.height);\n  }\n\n  hitTest(screenX: number, screenY: number): HitResult | null {\n    if (!this.dataset) return null;\n\n    const { positions, n } = this.dataset;\n    let bestIndex = -1;\n    let bestDistSq = Infinity;\n    const maxDistSq = (this.pointRadius + 5) ** 2; // Hit radius with padding\n\n    // Brute force: check all points\n    for (let i = 0; i < n; i++) {\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectEuclidean(dataX, dataY, this.view, this.width, this.height);\n\n      const dx = screen.x - screenX;\n      const dy = screen.y - screenY;\n      const distSq = dx * dx + dy * dy;\n\n      if (distSq < bestDistSq && distSq <= maxDistSq) {\n        bestDistSq = distSq;\n        bestIndex = i;\n      }\n    }\n\n    if (bestIndex < 0) return null;\n\n    const dataX = positions[bestIndex * 2];\n    const dataY = positions[bestIndex * 2 + 1];\n    const screen = projectEuclidean(dataX, dataY, this.view, this.width, this.height);\n\n    return {\n      index: bestIndex,\n      screenX: screen.x,\n      screenY: screen.y,\n      distance: Math.sqrt(bestDistSq),\n    };\n  }\n\n  lassoSelect(polyline: Float32Array): SelectionResult {\n    if (!this.dataset) {\n      return createIndicesSelectionResult(new Set(), 0);\n    }\n\n    const startTime = performance.now();\n\n    // Transform polyline from screen to data space\n    const dataPolyline = new Float32Array(polyline.length);\n    for (let i = 0; i < polyline.length / 2; i++) {\n      const screenX = polyline[i * 2];\n      const screenY = polyline[i * 2 + 1];\n      const data = unprojectEuclidean(screenX, screenY, this.view, this.width, this.height);\n      dataPolyline[i * 2] = data.x;\n      dataPolyline[i * 2 + 1] = data.y;\n    }\n\n    // Brute force selection\n    const indices = lassoSelectBruteForce(this.dataset.positions, dataPolyline);\n\n    const computeTimeMs = performance.now() - startTime;\n    return createIndicesSelectionResult(indices, computeTimeMs);\n  }\n\n  async countSelection(result: SelectionResult, _opts: CountSelectionOptions = {}): Promise<number> {\n    if (!result.indices) {\n      throw new Error('EuclideanReference.countSelection expects indices-based selections');\n    }\n    return result.indices.size;\n  }\n\n  projectToScreen(dataX: number, dataY: number): { x: number; y: number } {\n    return projectEuclidean(dataX, dataY, this.view, this.width, this.height);\n  }\n\n  unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number } {\n    return unprojectEuclidean(screenX, screenY, this.view, this.width, this.height);\n  }\n}\n","/**\n * Poincare disk (hyperbolic) geometry utilities.\n *\n * The Poincare disk model represents hyperbolic space inside the unit disk.\n * Points are represented as complex numbers z with |z| < 1.\n *\n * Isometries (distance-preserving transformations) are Mobius transformations\n * of the form: f(z) = (z - a) / (1 - conj(a) * z) where |a| < 1\n *\n * This maps point 'a' to the origin, which is our \"camera translation\".\n *\n * References:\n * - https://math.libretexts.org/Bookshelves/Geometry/Geometry_with_an_Introduction_to_Cosmic_Topology_(Hitchman)/05:_Hyperbolic_Geometry/5.01:_The_Poincare_Disk_Model\n * - https://geoopt.readthedocs.io/en/latest/extended/stereographic.html\n */\n\nimport { HyperbolicViewState } from '../types.js';\n\n/**\n * Create a default hyperbolic view state (centered at origin).\n */\nexport function createHyperbolicView(): HyperbolicViewState {\n  return {\n    type: 'poincare',\n    ax: 0,\n    ay: 0,\n    displayZoom: 1,\n  };\n}\n\n/**\n * Apply Mobius transformation: T_a(z) = (z - a) / (1 - conj(a) * z)\n * This is the hyperbolic isometry that translates 'a' to the origin.\n *\n * Mathematical derivation:\n * - Numerator: z - a (complex subtraction)\n * - Denominator: 1 - conj(a) * z where conj(a) = ax - i*ay\n */\nexport function mobiusTransform(\n  zx: number,\n  zy: number,\n  ax: number,\n  ay: number\n): { x: number; y: number } {\n  // Numerator: z - a\n  const numX = zx - ax;\n  const numY = zy - ay;\n\n  // Denominator: 1 - conj(a) * z = 1 - (ax - i*ay)(zx + i*zy)\n  // = 1 - (ax*zx + ay*zy + i*(ax*zy - ay*zx))\n  const denomX = 1 - (ax * zx + ay * zy);\n  const denomY = -(ax * zy - ay * zx);\n\n  // Complex division: num / denom\n  const denomNormSq = denomX * denomX + denomY * denomY;\n  if (denomNormSq < 1e-12) {\n    // Degenerate case, return clamped to boundary\n    const norm = Math.sqrt(numX * numX + numY * numY);\n    if (norm < 1e-12) return { x: 0, y: 0 };\n    return { x: (numX / norm) * 0.999, y: (numY / norm) * 0.999 };\n  }\n\n  const resultX = (numX * denomX + numY * denomY) / denomNormSq;\n  const resultY = (numY * denomX - numX * denomY) / denomNormSq;\n\n  // Clamp to disk (numerical safety)\n  const rSq = resultX * resultX + resultY * resultY;\n  if (rSq >= 1) {\n    const r = Math.sqrt(rSq);\n    return { x: (resultX / r) * 0.999, y: (resultY / r) * 0.999 };\n  }\n\n  return { x: resultX, y: resultY };\n}\n\n/**\n * Inverse Mobius transformation.\n * If forward is T_a(z) = (z - a) / (1 - conj(a) * z)\n * Then inverse is T_a^{-1}(w) = (w + a) / (1 + conj(a) * w)\n */\nexport function inverseMobiusTransform(\n  wx: number,\n  wy: number,\n  ax: number,\n  ay: number\n): { x: number; y: number } {\n  // Numerator: w + a\n  const numX = wx + ax;\n  const numY = wy + ay;\n\n  // Denominator: 1 + conj(a) * w = 1 + (ax - i*ay)(wx + i*wy)\n  // = 1 + (ax*wx + ay*wy + i*(ax*wy - ay*wx))\n  const denomX = 1 + (ax * wx + ay * wy);\n  const denomY = ax * wy - ay * wx;\n\n  // Complex division\n  const denomNormSq = denomX * denomX + denomY * denomY;\n  if (denomNormSq < 1e-12) {\n    const norm = Math.sqrt(numX * numX + numY * numY);\n    if (norm < 1e-12) return { x: 0, y: 0 };\n    return { x: (numX / norm) * 0.999, y: (numY / norm) * 0.999 };\n  }\n\n  const resultX = (numX * denomX + numY * denomY) / denomNormSq;\n  const resultY = (numY * denomX - numX * denomY) / denomNormSq;\n\n  const rSq = resultX * resultX + resultY * resultY;\n  if (rSq >= 1) {\n    const r = Math.sqrt(rSq);\n    return { x: (resultX / r) * 0.999, y: (resultY / r) * 0.999 };\n  }\n\n  return { x: resultX, y: resultY };\n}\n\n/**\n * Mobius addition (gyroaddition) in the Poincare ball.\n * Formula from geoopt for curvature k = -1:\n *\n * x ⊕ y = ((1 + 2⟨x,y⟩ + ‖y‖²)x + (1 - ‖x‖²)y) / (1 + 2⟨x,y⟩ + ‖x‖²‖y‖²)\n *\n * where ⟨x,y⟩ is the real inner product (dot product).\n */\nexport function mobiusAdd(\n  ax: number,\n  ay: number,\n  bx: number,\n  by: number\n): { x: number; y: number } {\n  const dotAB = ax * bx + ay * by; // ⟨a, b⟩\n  const normASq = ax * ax + ay * ay; // ‖a‖²\n  const normBSq = bx * bx + by * by; // ‖b‖²\n\n  // Numerator coefficients\n  const coeffA = 1 + 2 * dotAB + normBSq;\n  const coeffB = 1 - normASq;\n\n  // Denominator\n  const denom = 1 + 2 * dotAB + normASq * normBSq;\n\n  if (Math.abs(denom) < 1e-12) {\n    return { x: 0, y: 0 };\n  }\n\n  const resultX = (coeffA * ax + coeffB * bx) / denom;\n  const resultY = (coeffA * ay + coeffB * by) / denom;\n\n  // Clamp to disk\n  const rSq = resultX * resultX + resultY * resultY;\n  if (rSq >= 1) {\n    const r = Math.sqrt(rSq);\n    return { x: (resultX / r) * 0.99, y: (resultY / r) * 0.99 };\n  }\n\n  return { x: resultX, y: resultY };\n}\n\n/**\n * Mobius negation: -x in the gyrogroup is just negation.\n */\nexport function mobiusNeg(x: number, y: number): { x: number; y: number } {\n  return { x: -x, y: -y };\n}\n\n/**\n * Mobius subtraction: x ⊖ y = x ⊕ (-y)\n */\nexport function mobiusSub(\n  ax: number,\n  ay: number,\n  bx: number,\n  by: number\n): { x: number; y: number } {\n  return mobiusAdd(ax, ay, -bx, -by);\n}\n\n/**\n * Project a Poincare disk point to screen coordinates.\n */\nexport function projectPoincare(\n  dataX: number,\n  dataY: number,\n  view: HyperbolicViewState,\n  width: number,\n  height: number\n): { x: number; y: number } {\n  // First apply the Mobius transformation (camera)\n  const transformed = mobiusTransform(dataX, dataY, view.ax, view.ay);\n\n  // Then apply display zoom and map to screen\n  // The disk has radius 1, we map it to fit in the canvas\n  const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n  const x = width / 2 + transformed.x * diskRadius;\n  const y = height / 2 - transformed.y * diskRadius; // flip Y\n\n  return { x, y };\n}\n\n/**\n * Unproject screen coordinates to Poincare disk (data space).\n */\nexport function unprojectPoincare(\n  screenX: number,\n  screenY: number,\n  view: HyperbolicViewState,\n  width: number,\n  height: number\n): { x: number; y: number } {\n  // Map screen to disk coordinates (after camera)\n  const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n  const diskX = (screenX - width / 2) / diskRadius;\n  const diskY = -(screenY - height / 2) / diskRadius; // flip Y\n\n  // Check if point is outside disk\n  const rSq = diskX * diskX + diskY * diskY;\n  if (rSq >= 1) {\n    // Clamp to disk boundary\n    const r = Math.sqrt(rSq);\n    const clampedX = (diskX / r) * 0.999;\n    const clampedY = (diskY / r) * 0.999;\n    return inverseMobiusTransform(clampedX, clampedY, view.ax, view.ay);\n  }\n\n  // Apply inverse Mobius to get data coordinates\n  return inverseMobiusTransform(diskX, diskY, view.ax, view.ay);\n}\n\n/**\n * Solve for new camera position a' such that T_{a'}(p) = d2\n *\n * Given: data point p, target display position d2\n * Find: camera a' such that (p - a') / (1 - conj(a') * p) = d2\n *\n * This is solved as a linear system in the real and imaginary parts of a'.\n *\n * The system is:\n *   (1 - A) * x - B * y = px - d2x\n *   B * x - (1 + A) * y = d2y - py\n *\n * where A = d2x*px - d2y*py, B = d2x*py + d2y*px\n * and the determinant is A² + B² - 1 = |d2|²|p|² - 1\n */\nfunction solveForCamera(\n  px: number,\n  py: number,\n  d2x: number,\n  d2y: number\n): { x: number; y: number } {\n  const A = d2x * px - d2y * py;\n  const B = d2x * py + d2y * px;\n\n  // Determinant = |d2|² * |p|² - 1\n  // For points inside disk, this is always negative\n  const det = A * A + B * B - 1;\n\n  if (Math.abs(det) < 1e-10) {\n    // Degenerate case: either p or d2 is at origin, or on boundary\n    // Fall back to simple approximation\n    return { x: -d2x, y: -d2y };\n  }\n\n  const rhsX = px - d2x;\n  const rhsY = d2y - py;\n\n  // Cramer's rule\n  const x = (-(1 + A) * rhsX + B * rhsY) / det;\n  const y = ((1 - A) * rhsY - B * rhsX) / det;\n\n  // Clamp to ensure |a'| < 1\n  const rSq = x * x + y * y;\n  if (rSq >= 1) {\n    const r = Math.sqrt(rSq);\n    return { x: (x / r) * 0.99, y: (y / r) * 0.99 };\n  }\n\n  return { x, y };\n}\n\n/**\n * Apply pan to hyperbolic view (anchor-invariant).\n *\n * The point under the cursor at drag start should stay under the cursor\n * throughout the drag. This is the correct \"natural\" drag behavior.\n *\n * Algorithm:\n * 1. Find the data point p under the start screen position\n * 2. Get the target disk position d2 from end screen position\n * 3. Solve for new camera a' such that T_{a'}(p) = d2\n */\nexport function panPoincare(\n  view: HyperbolicViewState,\n  startScreenX: number,\n  startScreenY: number,\n  endScreenX: number,\n  endScreenY: number,\n  width: number,\n  height: number\n): HyperbolicViewState {\n  const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n\n  // Convert screen positions to disk coordinates (display space, after camera)\n  const d1x = (startScreenX - width / 2) / diskRadius;\n  const d1y = -(startScreenY - height / 2) / diskRadius;\n  const d2x = (endScreenX - width / 2) / diskRadius;\n  const d2y = -(endScreenY - height / 2) / diskRadius;\n\n  // Clamp to disk with margin\n  const clampToDisk = (x: number, y: number, maxR: number = 0.95) => {\n    const rSq = x * x + y * y;\n    if (rSq > maxR * maxR) {\n      const r = Math.sqrt(rSq);\n      return { x: (x / r) * maxR, y: (y / r) * maxR };\n    }\n    return { x, y };\n  };\n\n  const d1 = clampToDisk(d1x, d1y);\n  const d2 = clampToDisk(d2x, d2y);\n\n  // Get the data point currently displayed at d1\n  // p = T_a^{-1}(d1)\n  const p = inverseMobiusTransform(d1.x, d1.y, view.ax, view.ay);\n\n  // Solve for new camera a' such that T_{a'}(p) = d2\n  const newA = solveForCamera(p.x, p.y, d2.x, d2.y);\n\n  return {\n    ...view,\n    ax: newA.x,\n    ay: newA.y,\n  };\n}\n\n/**\n * Apply zoom to hyperbolic view (anchor-invariant).\n *\n * Display zoom scales the visual representation while keeping the\n * data point under the cursor stationary.\n */\nexport function zoomPoincare(\n  view: HyperbolicViewState,\n  anchorScreenX: number,\n  anchorScreenY: number,\n  delta: number,\n  width: number,\n  height: number\n): HyperbolicViewState {\n  // Calculate new display zoom\n  const zoomFactor = Math.pow(1.1, delta);\n  const newDisplayZoom = Math.max(0.5, Math.min(10, view.displayZoom * zoomFactor));\n\n  // Get the data point under the anchor\n  const dataPoint = unprojectPoincare(anchorScreenX, anchorScreenY, view, width, height);\n\n  // Calculate where this data point would appear with new zoom (but same camera)\n  const diskRadiusNew = Math.min(width, height) * 0.45 * newDisplayZoom;\n\n  // The display position of dataPoint after camera transform\n  const transformed = mobiusTransform(dataPoint.x, dataPoint.y, view.ax, view.ay);\n\n  // Screen position with new zoom (if we don't adjust camera)\n  const newScreenX = width / 2 + transformed.x * diskRadiusNew;\n  const newScreenY = height / 2 - transformed.y * diskRadiusNew;\n\n  // If the point moved significantly, adjust camera to compensate\n  const dx = newScreenX - anchorScreenX;\n  const dy = newScreenY - anchorScreenY;\n\n  if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\n    // Pan to bring the anchor point back under the cursor\n    return panPoincare(\n      { ...view, displayZoom: newDisplayZoom },\n      newScreenX,\n      newScreenY,\n      anchorScreenX,\n      anchorScreenY,\n      width,\n      height\n    );\n  }\n\n  return {\n    ...view,\n    displayZoom: newDisplayZoom,\n  };\n}\n\n/**\n * Hyperbolic distance between two points in the Poincare disk.\n * d(z1, z2) = 2 * arctanh(|z1 - z2| / |1 - conj(z1) * z2|)\n */\nexport function hyperbolicDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): number {\n  const diffX = x1 - x2;\n  const diffY = y1 - y2;\n  const diffNorm = Math.sqrt(diffX * diffX + diffY * diffY);\n\n  // 1 - conj(z1) * z2\n  const denomX = 1 - (x1 * x2 + y1 * y2);\n  const denomY = -(x1 * y2 - y1 * x2);\n  const denomNorm = Math.sqrt(denomX * denomX + denomY * denomY);\n\n  if (denomNorm < 1e-12) return Infinity;\n\n  // Clamp ratio to avoid atanh(1) = Infinity due to floating-point errors\n  const ratio = Math.min(diffNorm / denomNorm, 1 - 1e-10);\n\n  return 2 * Math.atanh(ratio);\n}\n\n/**\n * Geodesic interpolation between two points.\n * gamma(t) = x ⊕ (t ⊗ ((-x) ⊕ y))\n *\n * For simplicity, we use a linear approximation in disk space\n * which is accurate for small distances.\n */\nexport function geodesicInterpolate(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  t: number\n): { x: number; y: number } {\n  // Transform so x1 is at origin\n  const transformed = mobiusTransform(x2, y2, x1, y1);\n\n  // Scale by t (this is exact for geodesics through origin)\n  const scaledNorm = Math.sqrt(transformed.x * transformed.x + transformed.y * transformed.y);\n  if (scaledNorm < 1e-12) {\n    return { x: x1, y: y1 };\n  }\n\n  // Clamp to avoid atanh(1) = Infinity near boundary\n  const clampedNorm = Math.min(scaledNorm, 1 - 1e-10);\n\n  // Use arctanh/tanh for proper geodesic scaling\n  const targetNorm = Math.tanh(t * Math.atanh(clampedNorm));\n  const scaled = {\n    x: (transformed.x / scaledNorm) * targetNorm,\n    y: (transformed.y / scaledNorm) * targetNorm,\n  };\n\n  // Transform back\n  return inverseMobiusTransform(scaled.x, scaled.y, x1, y1);\n}\n","/**\n * Hyperbolic (Poincare Disk) Reference Implementation\n *\n * This is the naive but accurate Canvas2D implementation for hyperbolic space.\n * It serves as ground truth for comparison with optimized candidates.\n *\n * Key features:\n * - Correct Mobius transformation for camera navigation\n * - Anchor-invariant pan (point under cursor stays under cursor)\n * - Proper hyperbolic distance semantics\n * - Lasso selection in data space (unprojected)\n */\n\nimport {\n  Dataset,\n  Renderer,\n  InitOptions,\n  ViewState,\n  HyperbolicViewState,\n  Modifiers,\n  HitResult,\n  SelectionResult,\n  CountSelectionOptions,\n  DEFAULT_COLORS,\n  SELECTION_COLOR,\n  HOVER_COLOR,\n  createIndicesSelectionResult,\n} from '../core/types.js';\nimport {\n  createHyperbolicView,\n  projectPoincare,\n  unprojectPoincare,\n  panPoincare,\n  zoomPoincare,\n  mobiusTransform,\n} from '../core/math/poincare.js';\nimport { lassoSelectBruteForce } from '../core/selection/point_in_polygon.js';\n\nexport class HyperbolicReference implements Renderer {\n  private canvas!: HTMLCanvasElement;\n  private ctx!: CanvasRenderingContext2D;\n  private width = 0;\n  private height = 0;\n  private dpr = 1;\n\n  private dataset: Dataset | null = null;\n  private view: HyperbolicViewState = createHyperbolicView();\n  private selection = new Set<number>();\n  private hoveredIndex = -1;\n\n  private pointRadius = 3;\n  private colors = DEFAULT_COLORS;\n  private backgroundColor = '#0a0a0a';\n  private poincareDiskFillColor = '#141414';\n  private poincareDiskBorderColor = '#666666';\n  private poincareGridColor = '#2a2a2a';\n  private poincareDiskBorderWidthPx = 2;\n  private poincareGridWidthPx = 0.5;\n\n  init(canvas: HTMLCanvasElement, opts: InitOptions): void {\n    this.canvas = canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Failed to get 2D context');\n    this.ctx = ctx;\n\n    this.width = opts.width;\n    this.height = opts.height;\n    this.dpr = opts.devicePixelRatio ?? 1;\n\n    if (opts.backgroundColor) this.backgroundColor = opts.backgroundColor;\n    if (opts.pointRadius) this.pointRadius = opts.pointRadius;\n    if (opts.colors) this.colors = opts.colors;\n    if (opts.poincareDiskFillColor) this.poincareDiskFillColor = opts.poincareDiskFillColor;\n    if (opts.poincareDiskBorderColor) this.poincareDiskBorderColor = opts.poincareDiskBorderColor;\n    if (opts.poincareGridColor) this.poincareGridColor = opts.poincareGridColor;\n    if (typeof opts.poincareDiskBorderWidthPx === 'number' && Number.isFinite(opts.poincareDiskBorderWidthPx)) {\n      this.poincareDiskBorderWidthPx = Math.max(0, opts.poincareDiskBorderWidthPx);\n    }\n    if (typeof opts.poincareGridWidthPx === 'number' && Number.isFinite(opts.poincareGridWidthPx)) {\n      this.poincareGridWidthPx = Math.max(0, opts.poincareGridWidthPx);\n    }\n\n    // Set canvas size\n    canvas.width = this.width * this.dpr;\n    canvas.height = this.height * this.dpr;\n    canvas.style.width = `${this.width}px`;\n    canvas.style.height = `${this.height}px`;\n\n    // IMPORTANT: reset transform before applying DPR scaling.\n    // Canvas contexts persist their transform across getContext() calls and\n    // renderer swaps; repeated scale() would otherwise accumulate.\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  setDataset(dataset: Dataset): void {\n    if (dataset.geometry !== 'poincare') {\n      throw new Error('HyperbolicReference only supports poincare geometry');\n    }\n    this.dataset = dataset;\n    this.selection.clear();\n    this.hoveredIndex = -1;\n\n    // Reset view to center\n    this.view = createHyperbolicView();\n  }\n\n  setView(view: ViewState): void {\n    if (view.type !== 'poincare') {\n      throw new Error('HyperbolicReference only supports poincare view state');\n    }\n    this.view = view;\n  }\n\n  getView(): ViewState {\n    return { ...this.view };\n  }\n\n  setSelection(indices: Set<number>): void {\n    this.selection = new Set(indices);\n  }\n\n  getSelection(): Set<number> {\n    return new Set(this.selection);\n  }\n\n  setHovered(index: number): void {\n    this.hoveredIndex = index;\n  }\n\n  render(): void {\n    const { ctx, width, height, dataset, view } = this;\n    if (!dataset) return;\n\n    // Clear background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw the Poincare disk boundary\n    const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Disk background (slightly lighter)\n    ctx.fillStyle = this.poincareDiskFillColor;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, diskRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Disk border\n    ctx.strokeStyle = this.poincareDiskBorderColor;\n    ctx.lineWidth = this.poincareDiskBorderWidthPx;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, diskRadius, 0, Math.PI * 2);\n    ctx.stroke();\n\n    // Draw hyperbolic grid lines (geodesics) - optional but helpful for visualization\n    this.drawHyperbolicGrid(ctx, centerX, centerY, diskRadius);\n\n    // Draw all points\n    const { positions, labels, n } = dataset;\n    const radius = this.pointRadius;\n\n    // First pass: unselected points\n    for (let i = 0; i < n; i++) {\n      if (this.selection.has(i) || i === this.hoveredIndex) continue;\n\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectPoincare(dataX, dataY, view, width, height);\n\n      // Check if inside disk (after transform)\n      const dx = screen.x - centerX;\n      const dy = screen.y - centerY;\n      if (dx * dx + dy * dy > diskRadius * diskRadius) continue;\n\n      ctx.fillStyle = this.colors[labels[i] % this.colors.length];\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Second pass: selected points\n    ctx.fillStyle = SELECTION_COLOR;\n    for (const i of this.selection) {\n      if (i === this.hoveredIndex) continue;\n\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectPoincare(dataX, dataY, view, width, height);\n\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 1, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Third pass: hovered point\n    if (this.hoveredIndex >= 0 && this.hoveredIndex < n) {\n      const i = this.hoveredIndex;\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectPoincare(dataX, dataY, view, width, height);\n\n      ctx.strokeStyle = HOVER_COLOR;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 3, 0, Math.PI * 2);\n      ctx.stroke();\n\n      ctx.fillStyle = this.selection.has(i)\n        ? SELECTION_COLOR\n        : this.colors[labels[i] % this.colors.length];\n      ctx.beginPath();\n      ctx.arc(screen.x, screen.y, radius + 1, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  /**\n   * Draw hyperbolic geodesics through the origin.\n   * In the Poincare disk, geodesics through the origin are straight lines.\n   * Other geodesics are circular arcs perpendicular to the boundary.\n   */\n  private drawHyperbolicGrid(\n    ctx: CanvasRenderingContext2D,\n    centerX: number,\n    centerY: number,\n    diskRadius: number\n  ): void {\n    ctx.strokeStyle = this.poincareGridColor;\n    ctx.lineWidth = this.poincareGridWidthPx;\n\n    // Draw radial lines (geodesics through origin after camera transform)\n    const numRadial = 8;\n    for (let i = 0; i < numRadial; i++) {\n      const angle = (i / numRadial) * Math.PI;\n      ctx.beginPath();\n      ctx.moveTo(\n        centerX - diskRadius * Math.cos(angle),\n        centerY - diskRadius * Math.sin(angle)\n      );\n      ctx.lineTo(\n        centerX + diskRadius * Math.cos(angle),\n        centerY + diskRadius * Math.sin(angle)\n      );\n      ctx.stroke();\n    }\n\n    // Draw concentric circles (horocycles)\n    const numCircles = 5;\n    for (let i = 1; i <= numCircles; i++) {\n      const r = (i / (numCircles + 1)) * diskRadius;\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  resize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.canvas.width = width * this.dpr;\n    this.canvas.height = height * this.dpr;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  destroy(): void {\n    // Nothing to clean up for Canvas2D\n  }\n\n  // === Interaction Methods ===\n\n  private lastPanScreenX = 0;\n  private lastPanScreenY = 0;\n  private hasPanAnchor = false;\n\n  pan(deltaX: number, deltaY: number, _modifiers: Modifiers): void {\n    // Hyperbolic pan must be anchor-invariant w.r.t. the cursor.\n    // The `Renderer.pan()` contract only gives us incremental deltas, so we\n    // track the last known cursor position (set via startPan()).\n    //\n    // If startPan() was not called, fall back to using the canvas center as the\n    // anchor to avoid undefined behavior.\n    if (!this.hasPanAnchor) {\n      this.lastPanScreenX = this.width / 2;\n      this.lastPanScreenY = this.height / 2;\n      this.hasPanAnchor = true;\n    }\n\n    const startX = this.lastPanScreenX;\n    const startY = this.lastPanScreenY;\n    const endX = startX + deltaX;\n    const endY = startY + deltaY;\n\n    this.view = panPoincare(this.view, startX, startY, endX, endY, this.width, this.height);\n\n    this.lastPanScreenX = endX;\n    this.lastPanScreenY = endY;\n  }\n\n  /** Call this at the start of a pan gesture with the cursor position (in screen px). */\n  startPan(screenX: number, screenY: number): void {\n    this.lastPanScreenX = screenX;\n    this.lastPanScreenY = screenY;\n    this.hasPanAnchor = true;\n  }\n\n  zoom(anchorX: number, anchorY: number, delta: number, _modifiers: Modifiers): void {\n    this.view = zoomPoincare(this.view, anchorX, anchorY, delta, this.width, this.height);\n  }\n\n  hitTest(screenX: number, screenY: number): HitResult | null {\n    if (!this.dataset) return null;\n\n    const { positions, n } = this.dataset;\n    const { view, width, height } = this;\n\n    // Match render() culling: ignore points outside the displayed disk.\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n\n    let bestIndex = -1;\n    let bestDistSq = Infinity;\n    const maxDistSq = (this.pointRadius + 5) ** 2;\n\n    // Brute force: check all points\n    for (let i = 0; i < n; i++) {\n      const dataX = positions[i * 2];\n      const dataY = positions[i * 2 + 1];\n      const screen = projectPoincare(dataX, dataY, view, width, height);\n\n      const dxDisk = screen.x - centerX;\n      const dyDisk = screen.y - centerY;\n      if (dxDisk * dxDisk + dyDisk * dyDisk > diskRadius * diskRadius) continue;\n\n      const dx = screen.x - screenX;\n      const dy = screen.y - screenY;\n      const distSq = dx * dx + dy * dy;\n\n      if (distSq < bestDistSq && distSq <= maxDistSq) {\n        bestDistSq = distSq;\n        bestIndex = i;\n      }\n    }\n\n    if (bestIndex < 0) return null;\n\n    const dataX = positions[bestIndex * 2];\n    const dataY = positions[bestIndex * 2 + 1];\n    const screen = projectPoincare(dataX, dataY, view, width, height);\n\n    return {\n      index: bestIndex,\n      screenX: screen.x,\n      screenY: screen.y,\n      distance: Math.sqrt(bestDistSq),\n    };\n  }\n\n  lassoSelect(polyline: Float32Array): SelectionResult {\n    if (!this.dataset) {\n      return createIndicesSelectionResult(new Set(), 0);\n    }\n\n    const startTime = performance.now();\n\n    // Transform polyline from screen to data space (Poincare coordinates)\n    const dataPolyline = new Float32Array(polyline.length);\n    for (let i = 0; i < polyline.length / 2; i++) {\n      const screenX = polyline[i * 2];\n      const screenY = polyline[i * 2 + 1];\n      const data = unprojectPoincare(screenX, screenY, this.view, this.width, this.height);\n      dataPolyline[i * 2] = data.x;\n      dataPolyline[i * 2 + 1] = data.y;\n    }\n\n    // Brute force selection in data space\n    const indices = lassoSelectBruteForce(this.dataset.positions, dataPolyline);\n\n    const computeTimeMs = performance.now() - startTime;\n    return createIndicesSelectionResult(indices, computeTimeMs);\n  }\n\n  async countSelection(result: SelectionResult, _opts: CountSelectionOptions = {}): Promise<number> {\n    if (!result.indices) {\n      throw new Error('HyperbolicReference.countSelection expects indices-based selections');\n    }\n    return result.indices.size;\n  }\n\n  projectToScreen(dataX: number, dataY: number): { x: number; y: number } {\n    return projectPoincare(dataX, dataY, this.view, this.width, this.height);\n  }\n\n  unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number } {\n    return unprojectPoincare(screenX, screenY, this.view, this.width, this.height);\n  }\n}\n","/**\n * Spatial indexing helpers for fast hit-testing and lasso selection.\n *\n * Design goals:\n * - Deterministic and exact (matches reference semantics).\n * - No allocations in tight loops where practical.\n * - Works for both Euclidean and Poincaré datasets.\n */\n\nimport { pointInPolygon } from '../core/selection/point_in_polygon.js';\n\ninterface Bounds2D {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nfunction clampInt(v: number, lo: number, hi: number): number {\n  if (v < lo) return lo;\n  if (v > hi) return hi;\n  return v | 0;\n}\n\nfunction clamp(v: number, lo: number, hi: number): number {\n  return Math.max(lo, Math.min(hi, v));\n}\n\nfunction computeBounds(positions: Float32Array): Bounds2D {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < positions.length; i += 2) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    if (x < minX) minX = x;\n    if (x > maxX) maxX = x;\n    if (y < minY) minY = y;\n    if (y > maxY) maxY = y;\n  }\n\n  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {\n    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n  }\n\n  // Avoid degenerate ranges.\n  const eps = 1e-9;\n  if (Math.abs(maxX - minX) < eps) {\n    maxX = minX + 1;\n  }\n  if (Math.abs(maxY - minY) < eps) {\n    maxY = minY + 1;\n  }\n\n  return { minX, minY, maxX, maxY };\n}\n\n/**\n * Static uniform grid over a set of 2D points.\n *\n * This index is intended to be built once per dataset (data-space) and reused\n * across view changes. It supports fast AABB queries and radius queries.\n */\nexport class UniformGridIndex {\n  readonly n: number;\n  readonly bounds: Bounds2D;\n\n  readonly cellsX: number;\n  readonly cellsY: number;\n  readonly cellSizeX: number;\n  readonly cellSizeY: number;\n\n  /** offsets.length = cellsX*cellsY + 1 */\n  readonly offsets: Uint32Array;\n  /** ids.length = n (point indices packed per cell) */\n  readonly ids: Uint32Array;\n\n  constructor(positions: Float32Array, bounds?: Bounds2D, targetPointsPerCell = 64) {\n    this.n = (positions.length / 2) | 0;\n    this.bounds = bounds ?? computeBounds(positions);\n\n    const spanX = this.bounds.maxX - this.bounds.minX;\n    const spanY = this.bounds.maxY - this.bounds.minY;\n\n    // Choose cell count so average occupancy is ~targetPointsPerCell.\n    // totalCells ~= n / target\n    const totalCells = clamp(Math.ceil(this.n / Math.max(1, targetPointsPerCell)), 64, 1_000_000);\n\n    // Split cells across axes proportionally to aspect ratio.\n    const aspect = spanX / spanY;\n    let cellsX = Math.round(Math.sqrt(totalCells * aspect));\n    cellsX = clampInt(cellsX, 8, 2048);\n    let cellsY = Math.round(totalCells / cellsX);\n    cellsY = clampInt(cellsY, 8, 2048);\n\n    this.cellsX = cellsX;\n    this.cellsY = cellsY;\n    this.cellSizeX = spanX / cellsX;\n    this.cellSizeY = spanY / cellsY;\n\n    const cellCount = cellsX * cellsY;\n    const counts = new Uint32Array(cellCount);\n\n    // 1) Count points per cell\n    for (let i = 0; i < this.n; i++) {\n      const x = positions[i * 2];\n      const y = positions[i * 2 + 1];\n      const cx = clampInt(Math.floor((x - this.bounds.minX) / this.cellSizeX), 0, cellsX - 1);\n      const cy = clampInt(Math.floor((y - this.bounds.minY) / this.cellSizeY), 0, cellsY - 1);\n      counts[cy * cellsX + cx]++;\n    }\n\n    // 2) Prefix sums to offsets\n    const offsets = new Uint32Array(cellCount + 1);\n    let acc = 0;\n    for (let c = 0; c < cellCount; c++) {\n      offsets[c] = acc;\n      acc += counts[c];\n    }\n    offsets[cellCount] = acc;\n\n    // 3) Fill ids via running cursor\n    const cursor = offsets.slice(0, cellCount);\n    const ids = new Uint32Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      const x = positions[i * 2];\n      const y = positions[i * 2 + 1];\n      const cx = clampInt(Math.floor((x - this.bounds.minX) / this.cellSizeX), 0, cellsX - 1);\n      const cy = clampInt(Math.floor((y - this.bounds.minY) / this.cellSizeY), 0, cellsY - 1);\n      const cell = cy * cellsX + cx;\n      const dst = cursor[cell]++;\n      ids[dst] = i;\n    }\n\n    this.offsets = offsets;\n    this.ids = ids;\n  }\n\n  /**\n   * Iterate all point ids in cells overlapping the given AABB.\n   *\n   * This avoids allocating or filling a potentially enormous `out` array.\n   * It is especially important for large-N lasso selection benchmarks where\n   * the polygon AABB can cover many cells.\n   */\n  forEachInAABB(\n    minX: number,\n    minY: number,\n    maxX: number,\n    maxY: number,\n    visit: (id: number) => void\n  ): void {\n    const eps = 1e-12;\n    minX -= eps; minY -= eps; maxX += eps; maxY += eps;\n\n    const cx0 = clampInt(Math.floor((minX - this.bounds.minX) / this.cellSizeX), 0, this.cellsX - 1);\n    const cy0 = clampInt(Math.floor((minY - this.bounds.minY) / this.cellSizeY), 0, this.cellsY - 1);\n    const cx1 = clampInt(Math.floor((maxX - this.bounds.minX) / this.cellSizeX), 0, this.cellsX - 1);\n    const cy1 = clampInt(Math.floor((maxY - this.bounds.minY) / this.cellSizeY), 0, this.cellsY - 1);\n\n    for (let cy = cy0; cy <= cy1; cy++) {\n      const rowBase = cy * this.cellsX;\n      for (let cx = cx0; cx <= cx1; cx++) {\n        const cell = rowBase + cx;\n        const start = this.offsets[cell];\n        const end = this.offsets[cell + 1];\n        for (let k = start; k < end; k++) {\n          visit(this.ids[k]);\n        }\n      }\n    }\n  }\n\n  queryRadius(x: number, y: number, r: number, out: number[]): void {\n    out.length = 0;\n    this.forEachInAABB(x - r, y - r, x + r, y + r, (id) => out.push(id));\n  }\n}\n\nexport function lassoSelectIndexed(\n  positions: Float32Array,\n  polygonDataSpace: Float32Array,\n  index: UniformGridIndex\n): Set<number> {\n  const result: Set<number> = new Set<number>();\n\n  const nPoly = polygonDataSpace.length / 2;\n  if (nPoly < 3) return result;\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (let i = 0; i < polygonDataSpace.length; i += 2) {\n    const x = polygonDataSpace[i];\n    const y = polygonDataSpace[i + 1];\n    if (x < minX) minX = x;\n    if (x > maxX) maxX = x;\n    if (y < minY) minY = y;\n    if (y > maxY) maxY = y;\n  }\n\n  // For very large datasets, avoid building a huge candidates list.\n  // Iterate overlapping cells directly.\n  index.forEachInAABB(minX, minY, maxX, maxY, (i) => {\n    const x = positions[i * 2];\n    const y = positions[i * 2 + 1];\n    if (x < minX || x > maxX || y < minY || y > maxY) return;\n    if (pointInPolygon(x, y, polygonDataSpace)) {\n      result.add(i);\n    }\n  });\n\n  return result;\n}\n","/**\n * WebGL2 candidate renderers.\n *\n * Key idea:\n * - Keep all math (view state, project/unproject, pan/zoom) identical to reference\n *   by delegating to src/core/math/*.\n * - Move rendering to GPU (WebGL2 point sprites) for high throughput.\n * - Speed up hit-testing and lasso selection via spatial indexes.\n *\n * ---------------------------------------------------------------------------\n * Adaptive Quality / Performance Policy (budget-based)\n * ---------------------------------------------------------------------------\n * This renderer intentionally adapts quality to keep interaction smooth on\n * typical developer hardware.\n *\n * Instead of relying on point-count-only thresholds, we choose settings from\n * simple *work budgets*:\n *\n * 1) Fragment budget (fill-rate proxy)\n *    estFragments ≈ drawCount * π * r^2 * dpr^2\n *    where r is point radius in CSS pixels and dpr is the offscreen points-FBO\n *    pixel ratio (NOT necessarily window.devicePixelRatio).\n *\n * 2) Points FBO pixel budget (memory/bandwidth proxy)\n *    pointsPixels = (width * height) * dpr^2\n *\n * The policy chooses an offscreen points DPR that respects BOTH budgets. When\n * fragment pressure is high, we may switch from anti-aliased circles to faster\n * squares (with hysteresis) rather than doing it at a fixed N threshold.\n *\n * NOTE: These adaptations affect *rendering only*; hit-testing and lasso\n * selection remain exact (CPU-side) and must match the reference semantics.\n *\n * IMPORTANT:\n * - The browser benchmark/accuracy harness uses a *separate* hidden canvas for\n *   the WebGL candidate (a single <canvas> cannot hold both a 2D and WebGL\n *   context at the same time).\n * - This renderer still lazily creates its WebGL2 context only when `render()`\n *   is called, because the demo/harness may re-initialize renderers and we\n *   want `init()` to remain side-effect-light.\n */\n\nimport {\n  Dataset,\n  Renderer,\n  InitOptions,\n  ViewState,\n  EuclideanViewState,\n  HyperbolicViewState,\n  Modifiers,\n  HitResult,\n  SelectionResult,\n  SelectionGeometry,\n  CountSelectionOptions,\n  DEFAULT_COLORS,\n  SELECTION_COLOR,\n  HOVER_COLOR,\n  createIndicesSelectionResult,\n  createGeometrySelectionResult,\n} from '../core/types.js';\n\nimport {\n  createEuclideanView,\n  projectEuclidean,\n  unprojectEuclidean,\n  panEuclidean,\n  zoomEuclidean,\n} from '../core/math/euclidean.js';\n\nimport {\n  createHyperbolicView,\n  projectPoincare,\n  unprojectPoincare,\n  panPoincare,\n  zoomPoincare,\n} from '../core/math/poincare.js';\n\nimport {\n  UniformGridIndex,\n} from './spatial_index.js';\n\nimport { pointInPolygon } from '../core/selection/point_in_polygon.js';\n\n// ============================================================================\n// Small helpers\n// ============================================================================\n\nfunction parseHexColor(color: string): [number, number, number, number] {\n  // Accept: #rgb, #rrggbb, #rrggbbaa\n  const s = color.trim();\n  if (!s.startsWith('#')) return [1, 1, 1, 1];\n\n  const hex = s.slice(1);\n  if (hex.length === 3) {\n    const r = parseInt(hex[0] + hex[0], 16) / 255;\n    const g = parseInt(hex[1] + hex[1], 16) / 255;\n    const b = parseInt(hex[2] + hex[2], 16) / 255;\n    return [r, g, b, 1];\n  }\n  if (hex.length === 6 || hex.length === 8) {\n    const r = parseInt(hex.slice(0, 2), 16) / 255;\n    const g = parseInt(hex.slice(2, 4), 16) / 255;\n    const b = parseInt(hex.slice(4, 6), 16) / 255;\n    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;\n    return [r, g, b, a];\n  }\n\n  return [1, 1, 1, 1];\n}\n\nfunction parseHexColorBytes(color: string): [number, number, number, number] {\n  // Accept: #rgb, #rrggbb, #rrggbbaa\n  const s = color.trim();\n  if (!s.startsWith('#')) return [255, 255, 255, 255];\n\n  const hex = s.slice(1);\n  if (hex.length === 3) {\n    const r = parseInt(hex[0] + hex[0], 16);\n    const g = parseInt(hex[1] + hex[1], 16);\n    const b = parseInt(hex[2] + hex[2], 16);\n    return [r, g, b, 255];\n  }\n  if (hex.length === 6 || hex.length === 8) {\n    const r = parseInt(hex.slice(0, 2), 16);\n    const g = parseInt(hex.slice(2, 4), 16);\n    const b = parseInt(hex.slice(4, 6), 16);\n    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) : 255;\n    return [r, g, b, a];\n  }\n\n  return [255, 255, 255, 255];\n}\n\nfunction compileShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader {\n  const shader = gl.createShader(type);\n  if (!shader) throw new Error('Failed to create shader');\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const info = gl.getShaderInfoLog(shader) ?? 'unknown';\n    gl.deleteShader(shader);\n    throw new Error(`Shader compile failed: ${info}`);\n  }\n  return shader;\n}\n\nfunction linkProgram(gl: WebGL2RenderingContext, vsSource: string, fsSource: string): WebGLProgram {\n  const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);\n  const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);\n  const program = gl.createProgram();\n  if (!program) throw new Error('Failed to create program');\n\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n\n  gl.deleteShader(vs);\n  gl.deleteShader(fs);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const info = gl.getProgramInfoLog(program) ?? 'unknown';\n    gl.deleteProgram(program);\n    throw new Error(`Program link failed: ${info}`);\n  }\n\n  return program;\n}\n\nfunction setCanvasSize(canvas: HTMLCanvasElement, width: number, height: number, dpr: number): void {\n  canvas.width = Math.max(1, Math.floor(width * dpr));\n  canvas.height = Math.max(1, Math.floor(height * dpr));\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n}\n\n// Note: Palette upload is handled by WebGLRendererBase via a small palette\n// texture (supports arbitrary label counts) and cached upload buffers.\n\n// ============================================================================\n// Shader sources\n// ============================================================================\n\nconst FS_POINTS = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nflat in uint v_label;\n\n// Present in the vertex stage too; redeclare here so we can compute AA width.\nuniform float u_dpr;\nuniform float u_pointRadiusCss;\n\nuniform sampler2D u_paletteTex;\nuniform int u_paletteSize;\nuniform int u_paletteWidth;\n\nout vec4 outColor;\n\nvoid main() {\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n  // Anti-aliased circle: avoid harsh discard edges that can look like\n  // \"weird polygons\" at small sizes or without MSAA.\n  float r = length(p);\n  // Ensure at least ~1px transition (in point-local coordinates) so small\n  // points remain visually circular.\n  float radiusPx = max(u_pointRadiusCss * u_dpr, 1.0);\n  // Slightly wider than 1px helps circles stay round-looking when zoomed out\n  // (where points are perceptually tiny and aliasing is more obvious).\n  float aa = max(fwidth(r), 1.5 / radiusPx);\n  float alpha = 1.0 - smoothstep(1.0 - aa, 1.0 + aa, r);\n  if (alpha <= 0.0) discard;\n\n  int size = max(u_paletteSize, 1);\n  int w = max(u_paletteWidth, 1);\n  int idx = int(v_label) % size;\n  int x = idx % w;\n  int y = idx / w;\n  vec4 c = texelFetch(u_paletteTex, ivec2(x, y), 0);\n  outColor = vec4(c.rgb, c.a * alpha);\n}\n`;\n\n// Performance mode: square points (no discard).\n// This is often faster on some GPUs for very large point counts.\nconst FS_POINTS_SQUARE = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nflat in uint v_label;\n\nuniform sampler2D u_paletteTex;\nuniform int u_paletteSize;\nuniform int u_paletteWidth;\n\nout vec4 outColor;\n\nvoid main() {\n  int size = max(u_paletteSize, 1);\n  int w = max(u_paletteWidth, 1);\n  int idx = int(v_label) % size;\n  int x = idx % w;\n  int y = idx / w;\n  outColor = texelFetch(u_paletteTex, ivec2(x, y), 0);\n}\n`;\n\nconst FS_SOLID = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform float u_dpr;\nuniform float u_pointRadiusCss;\n\nuniform vec4 u_color;\nuniform float u_pointSizePx;\nuniform float u_ringThicknessPx;\nuniform int u_ringMode; // 0 = solid, 1 = ring\n\nout vec4 outColor;\n\nvoid main() {\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n  float r = length(p);\n  float radiusPx = max(u_pointRadiusCss * u_dpr, 1.0);\n  float aa = max(fwidth(r), 1.5 / radiusPx);\n  float outer = 1.0 - smoothstep(1.0 - aa, 1.0 + aa, r);\n  if (outer <= 0.0) discard;\n\n  float alpha = outer;\n\n  if (u_ringMode == 1) {\n    float radiusPx = u_pointSizePx * 0.5;\n    float t = clamp(u_ringThicknessPx / max(radiusPx, 1e-6), 0.0, 1.0);\n    float inner = 1.0 - t;\n    // Keep only the outer ring with an anti-aliased inner boundary.\n    float innerMask = smoothstep(inner - aa, inner + aa, r);\n    alpha *= innerMask;\n    if (alpha <= 0.0) discard;\n  }\n\n  outColor = vec4(u_color.rgb, u_color.a * alpha);\n}\n`;\n\n// Fullscreen triangle (no vertex attributes)\nconst VS_FULLSCREEN = `#version 300 es\nprecision highp float;\n\nout vec2 v_uv;\n\nvoid main() {\n  // Fullscreen triangle\n  // (-1,-1), (3,-1), (-1,3)\n  if (gl_VertexID == 0) {\n    gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n    v_uv = vec2(0.0, 0.0);\n  } else if (gl_VertexID == 1) {\n    gl_Position = vec4(3.0, -1.0, 0.0, 1.0);\n    v_uv = vec2(2.0, 0.0);\n  } else {\n    gl_Position = vec4(-1.0, 3.0, 0.0, 1.0);\n    v_uv = vec2(0.0, 2.0);\n  }\n}\n`;\n\n// Composite pass: draw points texture over the background using alpha.\nconst FS_COMPOSITE = `#version 300 es\nprecision highp float;\n\nin vec2 v_uv;\n\nuniform sampler2D u_tex;\n\nout vec4 outColor;\n\nvoid main() {\n  vec2 uv = clamp(v_uv, 0.0, 1.0);\n  outColor = texture(u_tex, uv);\n}\n`;\n\n// Poincaré disk background + border (matches reference styling closely)\n// Drawn as a single fullscreen pass. Outside the disk it discards, leaving the\n// cleared background color.\nconst FS_POINCARE_DISK = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform vec2 u_cssSize;\nuniform float u_dpr;\nuniform float u_displayZoom;\n\nuniform vec4 u_diskFillColor;\nuniform vec4 u_diskBorderColor;\nuniform vec4 u_gridColor;\nuniform float u_diskBorderWidthPx;\nuniform float u_gridWidthPx;\n\nout vec4 outColor;\n\nvoid main() {\n  // Convert framebuffer pixels to CSS pixels\n  vec2 fragCss = gl_FragCoord.xy / max(u_dpr, 1.0);\n  vec2 center = u_cssSize * 0.5;\n\n  float diskRadius = min(u_cssSize.x, u_cssSize.y) * 0.45 * u_displayZoom;\n  vec2 p = fragCss - center;\n  float dist = length(p);\n\n  // Reference-like styling\n  vec3 diskFill = u_diskFillColor.rgb;\n  vec3 diskBorder = u_diskBorderColor.rgb;\n\n  float borderWidth = max(u_diskBorderWidthPx, 0.0);\n  float halfW = 0.5 * borderWidth;\n\n  // Anti-aliasing width (CSS px). Keep at least 1px for crisp edges.\n  float aa = max(1.0, fwidth(dist));\n\n  // Discard outside disk+border region so the clear color remains intact.\n  if (dist > diskRadius + halfW + aa) discard;\n\n  // Outer fade for anti-aliased boundary\n  float outerAlpha = 1.0 - smoothstep(diskRadius + halfW - aa, diskRadius + halfW + aa, dist);\n\n  // Border mask\n  float borderInner = smoothstep(diskRadius - halfW - aa, diskRadius - halfW + aa, dist);\n  float borderOuter = 1.0 - smoothstep(diskRadius + halfW - aa, diskRadius + halfW + aa, dist);\n  float borderMask = clamp(borderInner * borderOuter, 0.0, 1.0);\n\n  vec3 col = mix(diskFill, diskBorder, borderMask);\n\n  // ------------------------------------------------------------------------\n  // Reference-like hyperbolic grid overlay\n  // ------------------------------------------------------------------------\n  // Matches HyperbolicReference.drawHyperbolicGrid():\n  // - 8 radial lines (geodesics through origin)\n  // - 5 concentric circles\n  vec3 gridCol = u_gridColor.rgb;\n  float gridWidth = max(u_gridWidthPx, 0.0);\n  float halfGrid = 0.5 * gridWidth;\n\n  // AA width for thin lines in CSS pixel space.\n  float aaLine = max(1.0, fwidth(dist));\n\n  float gridMask = 0.0;\n\n  // Concentric circles (5)\n  for (int i = 1; i <= 5; i++) {\n    float r = (float(i) / 6.0) * diskRadius;\n    float d = abs(dist - r);\n    float m = 1.0 - smoothstep(halfGrid - aaLine, halfGrid + aaLine, d);\n    gridMask = max(gridMask, m);\n  }\n\n  // Radial lines (8), angle = (i/8)*pi\n  // Distance to line through origin with direction (cos a, sin a): |cross(p, dir)|\n  for (int i = 0; i < 8; i++) {\n    float a = (float(i) / 8.0) * 3.141592653589793;\n    vec2 dir = vec2(cos(a), sin(a));\n    float d = abs(p.x * dir.y - p.y * dir.x);\n    float m = 1.0 - smoothstep(halfGrid - aaLine, halfGrid + aaLine, d);\n    gridMask = max(gridMask, m);\n  }\n\n  // Apply grid on top of disk fill/border. Use u_gridColor alpha as intensity.\n  col = mix(col, gridCol, clamp(gridMask, 0.0, 1.0) * clamp(u_gridColor.a, 0.0, 1.0));\n  outColor = vec4(col, outerAlpha);\n}\n`;\n\nconst VS_EUCLIDEAN = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout(location = 0) in vec2 a_pos;\nlayout(location = 1) in uint a_label;\n\nuniform vec2 u_center;\nuniform vec2 u_cssSize;\nuniform float u_zoom;\nuniform float u_dpr;\nuniform float u_pointRadiusCss;\n\nflat out uint v_label;\n\nvoid main() {\n  float baseScale = min(u_cssSize.x, u_cssSize.y) * 0.4 * u_zoom;\n  float sx = u_cssSize.x * 0.5 + (a_pos.x - u_center.x) * baseScale;\n  float sy = u_cssSize.y * 0.5 - (a_pos.y - u_center.y) * baseScale;\n\n  vec2 dbufSize = u_cssSize * u_dpr;\n  vec2 dbuf = vec2(sx, sy) * u_dpr;\n\n  float cx = (dbuf.x / dbufSize.x) * 2.0 - 1.0;\n  float cy = 1.0 - (dbuf.y / dbufSize.y) * 2.0;\n\n  gl_Position = vec4(cx, cy, 0.0, 1.0);\n  gl_PointSize = (u_pointRadiusCss * 2.0) * u_dpr;\n  v_label = a_label;\n}\n`;\n\nconst VS_POINCARE = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout(location = 0) in vec2 a_pos;\nlayout(location = 1) in uint a_label;\n\nuniform vec2 u_cssSize;\nuniform float u_dpr;\nuniform float u_pointRadiusCss;\n\nuniform vec2 u_a;            // camera translation (ax, ay)\nuniform float u_displayZoom; // visual zoom\n\nflat out uint v_label;\n\nvec2 mobiusTransform(vec2 z, vec2 a) {\n  // (z - a) / (1 - conj(a) * z)\n  vec2 num = z - a;\n\n  // denom = 1 - (ax*zx + ay*zy)  + i * (-(ax*zy - ay*zx))\n  float denomX = 1.0 - (a.x * z.x + a.y * z.y);\n  float denomY = -(a.x * z.y - a.y * z.x);\n  float denomNormSq = denomX * denomX + denomY * denomY;\n  if (denomNormSq < 1e-12) {\n    // Push outside clip\n    return vec2(2.0, 2.0);\n  }\n\n  // complex division\n  float rx = (num.x * denomX + num.y * denomY) / denomNormSq;\n  float ry = (num.y * denomX - num.x * denomY) / denomNormSq;\n  return vec2(rx, ry);\n}\n\nvoid main() {\n  vec2 w = mobiusTransform(a_pos, u_a);\n  float r2 = dot(w, w);\n  if (r2 >= 1.0) {\n    gl_Position = vec4(2.0, 2.0, 0.0, 1.0);\n    gl_PointSize = 0.0;\n    v_label = a_label;\n    return;\n  }\n\n  float diskRadius = min(u_cssSize.x, u_cssSize.y) * 0.45 * u_displayZoom;\n  float sx = u_cssSize.x * 0.5 + w.x * diskRadius;\n  float sy = u_cssSize.y * 0.5 - w.y * diskRadius;\n\n  vec2 dbufSize = u_cssSize * u_dpr;\n  vec2 dbuf = vec2(sx, sy) * u_dpr;\n\n  float cx = (dbuf.x / dbufSize.x) * 2.0 - 1.0;\n  float cy = 1.0 - (dbuf.y / dbufSize.y) * 2.0;\n\n  gl_Position = vec4(cx, cy, 0.0, 1.0);\n  gl_PointSize = (u_pointRadiusCss * 2.0) * u_dpr;\n  v_label = a_label;\n}\n`;\n\n// ============================================================================\n// Base WebGL renderer (lazy context init)\n// ============================================================================\n\ntype GeometryKind = 'euclidean' | 'poincare';\n\nabstract class WebGLRendererBase implements Renderer {\n  protected canvas: HTMLCanvasElement | null = null;\n  protected width = 0;\n  protected height = 0;\n  protected deviceDpr = 1;\n  // Canvas DPR (drawing buffer for the final composite). Keep at device DPR so\n  // thin background/grid lines match the reference.\n  protected canvasDpr = 1;\n  // Points DPR (adaptive). We render points into a low-res offscreen buffer and\n  // composite it onto the full-res canvas.\n  protected dpr = 1;\n\n  protected dataset: Dataset | null = null;\n  protected selection = new Set<number>();\n  protected hoveredIndex = -1;\n\n  protected pointRadiusCss = 3;\n  protected colors: string[] = DEFAULT_COLORS;\n  protected backgroundColor = '#0a0a0a';\n\n  // Hyperbolic backdrop styling (Poincaré disk). Neutral grayscale defaults.\n  // Override per app via InitOptions as needed.\n  protected poincareDiskFillColor = '#141414';\n  protected poincareDiskBorderColor = '#666666';\n  protected poincareGridColor = '#66666633';\n  protected poincareDiskBorderWidthPx = 2;\n  protected poincareGridWidthPx = 0.5;\n\n  // Palette (label -> RGBA). Implemented as a small 2D texture so we can\n  // support arbitrary label counts (not limited to 16 uniforms).\n  protected paletteSize = 0;\n  protected paletteDirty = true;\n  protected paletteTex: WebGLTexture | null = null;\n  protected paletteTexW = 0;\n  protected paletteTexH = 0;\n  protected paletteBytes = new Uint8Array(0);\n  protected readonly paletteTexUnit = 1;\n\n  // Scratch arrays (avoid per-call allocations in hit testing / selection)\n  protected scratchIds: number[] = [];\n\n  // Scratch typed arrays for hover uploads (avoid per-frame allocations)\n  protected hoverPosScratch = new Float32Array(2);\n  protected hoverLabScratch = new Uint16Array(1);\n  protected hoverIndexScratch = new Uint32Array(1);\n\n  // Interaction-adaptive rendering (used to keep panning smooth at very large N)\n  protected lastViewChangeTs = 0;\n\n  protected markViewChanged(): void {\n    // performance.now() is available in browsers; in non-DOM contexts this class\n    // isn't used.\n    this.lastViewChangeTs = performance.now();\n  }\n\n  /**\n   * Optional UI hook: call when the user ends an interaction (mouse up / gesture end).\n   *\n   * The renderer uses `lastViewChangeTs` to decide whether to enable interaction\n   * LOD (subsampling) for smooth panning/zooming. In the demo app we only render\n   * on demand; if the final frame after mouseup is still considered \"interacting\",\n   * we can end up showing a subsample until the next hover-triggered render,\n   * which looks like a visual snap/pop.\n   *\n   * By resetting the interaction timer, the next render will use the stable\n   * (non-interaction) policy immediately.\n   */\n  endInteraction(): void {\n    this.lastViewChangeTs = 0;\n  }\n\n  protected markBackdropDirty(): void {\n    this.backdropDirty = true;\n  }\n\n  protected uploadPoincareDiskStyleUniforms(): void {\n    const gl = this.gl;\n    const disk = this.poincareDisk;\n    if (!gl || !disk) return;\n\n    const fill = parseHexColor(this.poincareDiskFillColor);\n    const border = parseHexColor(this.poincareDiskBorderColor);\n    const grid = parseHexColor(this.poincareGridColor);\n\n    if (disk.uDiskFillColor) gl.uniform4f(disk.uDiskFillColor, fill[0], fill[1], fill[2], fill[3]);\n    if (disk.uDiskBorderColor) gl.uniform4f(disk.uDiskBorderColor, border[0], border[1], border[2], border[3]);\n    if (disk.uGridColor) gl.uniform4f(disk.uGridColor, grid[0], grid[1], grid[2], grid[3]);\n    if (disk.uDiskBorderWidthPx) gl.uniform1f(disk.uDiskBorderWidthPx, this.poincareDiskBorderWidthPx);\n    if (disk.uGridWidthPx) gl.uniform1f(disk.uGridWidthPx, this.poincareGridWidthPx);\n  }\n\n  // Overridden by the hyperbolic renderer.\n  protected getBackdropZoom(): number {\n    return 1;\n  }\n\n  // CPU spatial index (data space)\n  protected dataIndex: UniformGridIndex | null = null;\n\n  // WebGL state (created lazily in render())\n  protected gl: WebGL2RenderingContext | null = null;\n  protected vao: WebGLVertexArrayObject | null = null;\n  protected posBuffer: WebGLBuffer | null = null;\n  protected labelBuffer: WebGLBuffer | null = null;\n\n  // Overlay buffers (used when main GPU buffers are a subsample).\n  protected hoverVao: WebGLVertexArrayObject | null = null;\n  protected hoverPosBuffer: WebGLBuffer | null = null;\n  protected hoverLabelBuffer: WebGLBuffer | null = null;\n\n  protected selectionVao: WebGLVertexArrayObject | null = null;\n  protected selectionPosBuffer: WebGLBuffer | null = null;\n  protected selectionLabelBuffer: WebGLBuffer | null = null;\n  protected selectionOverlayCount = 0;\n\n  protected selectionEbo: WebGLBuffer | null = null;\n  protected hoverEbo: WebGLBuffer | null = null;\n  protected interactionEbo: WebGLBuffer | null = null;\n  protected interactionCount = 0;\n\n  // Practical cap for vertex work in the base pass at very large N.\n  // For 20M datasets, drawing all points every frame is often vertex-bound;\n  // we instead draw a deterministic subsample and keep interaction semantics\n  // exact via CPU hit-testing + exact lasso.\n  //\n  // This does *not* affect the accuracy harness, which compares math + hit/lasso\n  // results rather than pixel output.\n  protected maxBaseDrawPoints = 4_000_000;\n\n  // Above this, upload only a deterministic subsample to GPU to avoid huge\n  // GPU allocations / upload stalls at 10M-20M points.\n  protected maxGpuUploadPoints = 10_000_000;\n  protected gpuUsesFullDataset = true;\n  protected gpuPointCount = 0;\n\n  // -------------------------------------------------------------------------\n  // Policy knobs (tuned via benchmarks; intended to generalize across hardware)\n  // -------------------------------------------------------------------------\n\n  protected policy = {\n    // Rough target for 60 FPS. This is a proxy budget (fragment invocations).\n    // If you change point radius defaults, re-evaluate this budget.\n    fragmentBudget: 100_000_000,\n\n    // Circles (AA + discard) are noticeably more expensive per-fragment than\n    // squares. Use a separate (lower) threshold for when we allow circles.\n    // Above this, prefer squares even if we're still under fragmentBudget.\n    circleBudget: 60_000_000,\n\n    // Hysteresis for circle<->square switching.\n    // Switch ON squares when estimated fragment load is high;\n    // switch back OFF when comfortably below the threshold.\n    squareOnRatio: 1.0,\n    squareOffRatio: 0.75,\n\n    // Minimum acceptable offscreen DPR for points (quality floor).\n    // Keeping this too high can cause perf cliffs at huge N; too low can make\n    // points overly blurry.\n    minPointsDpr: 0.35,\n  } as const;\n\n  // Sticky render mode (to avoid per-frame flip-flops)\n  protected renderAsSquares = false;\n\n  // Exposed for benchmarks (read via reflection)\n  public __debugPolicy: any = null;\n\n  // Cached hyperbolic backdrop (disk + grid) rendered to an offscreen texture.\n  // Rendering the backdrop shader every frame is expensive; we render it only\n  // when size/DPR or displayZoom changes, then blit the cached image.\n  protected backdropTex: WebGLTexture | null = null;\n  protected backdropFbo: WebGLFramebuffer | null = null;\n  protected backdropW = 0;\n  protected backdropH = 0;\n  protected backdropDpr = 1;\n  protected backdropZoom = NaN;\n  protected backdropDirty = true;\n\n  // Low-res points render target (adaptive DPR)\n  protected pointsTex: WebGLTexture | null = null;\n  protected pointsFbo: WebGLFramebuffer | null = null;\n  protected pointsW = 0;\n  protected pointsH = 0;\n\n  // Program for compositing the points texture to the main framebuffer\n  protected programComposite: WebGLProgram | null = null;\n  protected uCompositeTex: WebGLUniformLocation | null = null;\n\n  protected poincareDisk: {\n    program: WebGLProgram;\n    uCssSize: WebGLUniformLocation | null;\n    uDpr: WebGLUniformLocation | null;\n    uDiskFillColor: WebGLUniformLocation | null;\n    uDiskBorderColor: WebGLUniformLocation | null;\n    uGridColor: WebGLUniformLocation | null;\n    uDiskBorderWidthPx: WebGLUniformLocation | null;\n    uGridWidthPx: WebGLUniformLocation | null;\n    // u_displayZoom is set via bindViewUniformsForProgram() (Hyperbolic)\n  } | null = null;\n\n  protected pointsCircle: {\n    program: WebGLProgram;\n    uPaletteTex: WebGLUniformLocation | null;\n    uPaletteSize: WebGLUniformLocation | null;\n    uPaletteWidth: WebGLUniformLocation | null;\n    uCssSize: WebGLUniformLocation | null;\n    uDpr: WebGLUniformLocation | null;\n    uPointRadius: WebGLUniformLocation | null;\n  } | null = null;\n\n  protected pointsSquare: {\n    program: WebGLProgram;\n    uPaletteTex: WebGLUniformLocation | null;\n    uPaletteSize: WebGLUniformLocation | null;\n    uPaletteWidth: WebGLUniformLocation | null;\n    uCssSize: WebGLUniformLocation | null;\n    uDpr: WebGLUniformLocation | null;\n    uPointRadius: WebGLUniformLocation | null;\n  } | null = null;\n\n  protected programSolid: WebGLProgram | null = null;\n\n  // Uniform locations (solid)\n  protected uSolidColor: WebGLUniformLocation | null = null;\n  protected uSolidPointSizePx: WebGLUniformLocation | null = null;\n  protected uSolidRingThicknessPx: WebGLUniformLocation | null = null;\n  protected uSolidRingMode: WebGLUniformLocation | null = null;\n\n  protected uCssSizeSolid: WebGLUniformLocation | null = null;\n  protected uDprSolid: WebGLUniformLocation | null = null;\n  protected uPointRadiusSolid: WebGLUniformLocation | null = null;\n\n  protected selectionDirty = true;\n  protected hoverDirty = true;\n\n  init(canvas: HTMLCanvasElement, opts: InitOptions): void {\n    this.canvas = canvas;\n    this.width = opts.width;\n    this.height = opts.height;\n    this.deviceDpr = opts.devicePixelRatio ?? window.devicePixelRatio ?? 1;\n    this.canvasDpr = this.deviceDpr;\n    this.dpr = this.deviceDpr;\n\n    const hasDiskFillOverride = typeof opts.poincareDiskFillColor === 'string';\n    if (opts.backgroundColor) this.backgroundColor = opts.backgroundColor;\n    if (opts.pointRadius) this.pointRadiusCss = opts.pointRadius;\n    if (opts.colors) this.colors = opts.colors;\n\n    // Optional per-app styling for hyperbolic disk/grid.\n    // If the app did not specify a disk fill, keep the neutral default.\n    this.poincareDiskFillColor = hasDiskFillOverride\n      ? opts.poincareDiskFillColor!\n      : this.poincareDiskFillColor;\n    if (opts.poincareDiskBorderColor) this.poincareDiskBorderColor = opts.poincareDiskBorderColor;\n    if (opts.poincareGridColor) this.poincareGridColor = opts.poincareGridColor;\n    if (typeof opts.poincareDiskBorderWidthPx === 'number' && Number.isFinite(opts.poincareDiskBorderWidthPx)) {\n      this.poincareDiskBorderWidthPx = Math.max(0, opts.poincareDiskBorderWidthPx);\n    }\n    if (typeof opts.poincareGridWidthPx === 'number' && Number.isFinite(opts.poincareGridWidthPx)) {\n      this.poincareGridWidthPx = Math.max(0, opts.poincareGridWidthPx);\n    }\n\n    this.paletteDirty = true;\n\n    // IMPORTANT:\n    // Do NOT touch `canvas.width/height` here.\n    // The accuracy harness initializes reference and candidate on the same\n    // canvas; resizing would reset the reference's 2D context.\n    // We size the canvas only when we actually acquire a WebGL context.\n  }\n\n  protected chooseRenderDpr(pointCount: number): number {\n    const d = this.deviceDpr;\n    const cssPixels = Math.max(1, this.width) * Math.max(1, this.height);\n\n    // Expected draw count for rendering. For very large datasets we expect to\n    // draw a deterministic subsample (LOD) rather than all points.\n    const expectedDrawCount = pointCount > this.maxBaseDrawPoints\n      ? this.estimateSubsampleCount(pointCount)\n      : pointCount;\n\n    // Budget 1: points-FBO pixel budget (memory / bandwidth proxy).\n    // These numbers were originally tuned empirically; we keep them but treat\n    // them explicitly as a *budget* rather than a point-count threshold.\n    const pointsFboPixelBudget =\n      pointCount >= 1_000_000\n        ? (cssPixels > 1_000_000 ? 200_000 : 500_000)\n        : pointCount >= 500_000\n          ? 1_400_000\n          : pointCount >= 250_000\n            ? 2_100_000\n            : 8_000_000; // cap allocations for very large canvases even at small N\n\n    const dprFromPointsPixels = Math.sqrt(pointsFboPixelBudget / cssPixels);\n\n    // Budget 2: fragment budget (fill-rate proxy).\n    // estFragments ≈ N * π * r^2 * dpr^2  =>  dpr <= sqrt(budget / (N * π * r^2))\n    const r = Math.max(0.5, this.pointRadiusCss);\n    const denom = Math.max(1, expectedDrawCount) * Math.PI * r * r;\n    const dprFromFragments = Math.sqrt(this.policy.fragmentBudget / denom);\n\n    // Cap for stability (avoid huge offscreen buffers) and quality.\n    const cap = pointCount >= 1_000_000 ? 1.0 : pointCount >= 500_000 ? 1.25 : 1.5;\n    const floor = pointCount >= 1_000_000 ? this.policy.minPointsDpr : pointCount >= 500_000 ? 0.75 : 1.0;\n\n    const chosen = Math.min(d, cap, dprFromPointsPixels, dprFromFragments);\n    return Math.max(floor, chosen);\n  }\n\n  protected estimateSubsampleCount(n: number): number {\n    // Mirrors uploadDatasetToGPU() subsample logic, but used for budgeting.\n    if (n < 500_000) return n;\n    const target = Math.min(n, Math.max(250_000, Math.min(this.maxBaseDrawPoints, Math.floor(n * 0.25))));\n    const step = Math.max(1, Math.floor(n / target));\n    const count = Math.min(target, Math.ceil(n / step));\n    return count;\n  }\n\n  protected estimatePointFragments(drawCount: number, pointsDpr: number): number {\n    // Proxy for total fragment shader invocations spent on point sprites.\n    // This is intentionally simple and stable.\n    const r = Math.max(0.5, this.pointRadiusCss);\n    const n = Math.max(0, drawCount);\n    const dpr = Math.max(0, pointsDpr);\n    return n * Math.PI * r * r * dpr * dpr;\n  }\n\n  protected updateSquarePointPolicy(estimatedFragments: number): void {\n    // Switch based on the circle budget, not the overall fragment budget.\n    const on = this.policy.circleBudget * this.policy.squareOnRatio;\n    const off = this.policy.circleBudget * this.policy.squareOffRatio;\n\n    // If we're rendering points at a reduced offscreen DPR, the AA circle shader\n    // tends to be a poor trade (extra ALU + discard) while visual fidelity is\n    // already limited by resolution. Prefer squares in that regime.\n    const forceSquaresForLowDpr = this.dpr <= 0.75;\n    if (forceSquaresForLowDpr) {\n      this.renderAsSquares = true;\n      return;\n    }\n\n    if (!this.renderAsSquares) {\n      if (estimatedFragments >= on) this.renderAsSquares = true;\n    } else {\n      if (estimatedFragments <= off) this.renderAsSquares = false;\n    }\n  }\n\n  setDataset(dataset: Dataset): void {\n    this.dataset = dataset;\n    // Reset selection without mutating any external object passed via setSelection().\n    this.selection = new Set<number>();\n    this.hoveredIndex = -1;\n    this.selectionDirty = true;\n    this.hoverDirty = true;\n\n    // Potentially clamp points-FBO DPR for large datasets (performance priority).\n    const nextDpr = this.chooseRenderDpr(dataset.n);\n    if (nextDpr !== this.dpr) {\n      this.dpr = nextDpr;\n    }\n\n    // Bounds are computed internally by UniformGridIndex if omitted.\n    this.dataIndex = new UniformGridIndex(dataset.positions, undefined, 64);\n\n    // If WebGL is already active (performance benchmarks), upload immediately.\n    if (this.gl) {\n      this.uploadDatasetToGPU();\n    }\n\n    // Dataset changes don't affect the backdrop, but point DPR might have changed.\n    this.markBackdropDirty();\n  }\n\n  abstract setView(view: ViewState): void;\n  abstract getView(): ViewState;\n\n  resize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n\n    // Only resize the drawing buffer when we own a WebGL context.\n    if (this.gl && this.canvas) {\n      setCanvasSize(this.canvas, width, height, this.canvasDpr);\n      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n      this.markBackdropDirty();\n    }\n  }\n\n  setSelection(indices: Set<number>): void {\n    // IMPORTANT: Do not eagerly clone huge selections into a JS Set.\n    // For large-N lasso this can OOM. We keep the provided Set-like object.\n    // For small sets, clone to keep reference semantics similar to reference impls.\n    const n = indices.size;\n    this.selection = n <= 200_000 ? new Set(indices) : indices;\n    this.selectionDirty = true;\n\n    if (this.gl) {\n      this.uploadSelectionToGPU();\n    }\n  }\n\n  getSelection(): Set<number> {\n    // Returning a cloned Set is nice for encapsulation, but can OOM for huge\n    // selections. For large selections, return the internal Set-like object.\n    return this.selection.size <= 200_000 ? new Set(this.selection) : this.selection;\n  }\n\n  setHovered(index: number): void {\n    this.hoveredIndex = index;\n    this.hoverDirty = true;\n\n    if (this.gl) {\n      this.uploadHoverToGPU();\n    }\n  }\n\n  destroy(): void {\n    const gl = this.gl;\n\n    if (gl) {\n      if (this.pointsCircle) gl.deleteProgram(this.pointsCircle.program);\n      if (this.pointsSquare) gl.deleteProgram(this.pointsSquare.program);\n      if (this.programSolid) gl.deleteProgram(this.programSolid);\n      if (this.poincareDisk) gl.deleteProgram(this.poincareDisk.program);\n      if (this.vao) gl.deleteVertexArray(this.vao);\n      if (this.hoverVao) gl.deleteVertexArray(this.hoverVao);\n      if (this.selectionVao) gl.deleteVertexArray(this.selectionVao);\n      if (this.posBuffer) gl.deleteBuffer(this.posBuffer);\n      if (this.labelBuffer) gl.deleteBuffer(this.labelBuffer);\n      if (this.hoverPosBuffer) gl.deleteBuffer(this.hoverPosBuffer);\n      if (this.hoverLabelBuffer) gl.deleteBuffer(this.hoverLabelBuffer);\n      if (this.selectionPosBuffer) gl.deleteBuffer(this.selectionPosBuffer);\n      if (this.selectionLabelBuffer) gl.deleteBuffer(this.selectionLabelBuffer);\n      if (this.selectionEbo) gl.deleteBuffer(this.selectionEbo);\n      if (this.hoverEbo) gl.deleteBuffer(this.hoverEbo);\n      if (this.interactionEbo) gl.deleteBuffer(this.interactionEbo);\n      if (this.backdropFbo) gl.deleteFramebuffer(this.backdropFbo);\n      if (this.backdropTex) gl.deleteTexture(this.backdropTex);\n      if (this.pointsFbo) gl.deleteFramebuffer(this.pointsFbo);\n      if (this.pointsTex) gl.deleteTexture(this.pointsTex);\n      if (this.paletteTex) gl.deleteTexture(this.paletteTex);\n      if (this.programComposite) gl.deleteProgram(this.programComposite);\n    }\n\n    this.gl = null;\n    this.vao = null;\n    this.hoverVao = null;\n    this.selectionVao = null;\n    this.posBuffer = null;\n    this.labelBuffer = null;\n    this.hoverPosBuffer = null;\n    this.hoverLabelBuffer = null;\n    this.selectionPosBuffer = null;\n    this.selectionLabelBuffer = null;\n    this.selectionOverlayCount = 0;\n    this.selectionEbo = null;\n    this.hoverEbo = null;\n    this.interactionEbo = null;\n    this.interactionCount = 0;\n    this.gpuUsesFullDataset = true;\n    this.gpuPointCount = 0;\n    this.backdropFbo = null;\n    this.backdropTex = null;\n    this.backdropW = 0;\n    this.backdropH = 0;\n    this.backdropDpr = 1;\n    this.backdropZoom = NaN;\n    this.backdropDirty = true;\n\n    this.pointsFbo = null;\n    this.pointsTex = null;\n    this.pointsW = 0;\n    this.pointsH = 0;\n\n    this.programComposite = null;\n    this.uCompositeTex = null;\n    this.pointsCircle = null;\n    this.pointsSquare = null;\n    this.programSolid = null;\n    this.poincareDisk = null;\n\n    this.paletteTex = null;\n    this.paletteTexW = 0;\n    this.paletteTexH = 0;\n    this.paletteSize = 0;\n    this.paletteDirty = true;\n  }\n\n  protected uploadPaletteUniforms(): void {\n    const gl = this.gl;\n    if (!gl) return;\n\n    const rawSize = this.colors.length;\n    // Labels are Uint16 in the dataset, so the max addressable palette size is 65536.\n    const size = Math.max(1, Math.min(rawSize, 0xffff + 1));\n\n    const maxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE) as number;\n    const texW = Math.min(maxTex, size);\n    const texH = Math.ceil(size / texW);\n    if (texH > maxTex) {\n      throw new Error(`Palette too large for WebGL texture: size=${size}, maxTex=${maxTex}`);\n    }\n\n    // Allocate upload buffer (RGBA8)\n    const capacity = texW * texH;\n    if (this.paletteBytes.length !== capacity * 4) {\n      this.paletteBytes = new Uint8Array(capacity * 4);\n    } else {\n      this.paletteBytes.fill(0);\n    }\n\n    if (rawSize === 0) {\n      // Fallback: opaque white\n      this.paletteBytes[0] = 255;\n      this.paletteBytes[1] = 255;\n      this.paletteBytes[2] = 255;\n      this.paletteBytes[3] = 255;\n    } else {\n      for (let i = 0; i < size; i++) {\n        const [r, g, b, a] = parseHexColorBytes(this.colors[i]);\n        const o = i * 4;\n        this.paletteBytes[o + 0] = r;\n        this.paletteBytes[o + 1] = g;\n        this.paletteBytes[o + 2] = b;\n        this.paletteBytes[o + 3] = a;\n      }\n    }\n\n    if (!this.paletteTex) {\n      this.paletteTex = gl.createTexture();\n      if (!this.paletteTex) throw new Error('Failed to create palette texture');\n      gl.activeTexture(gl.TEXTURE0 + this.paletteTexUnit);\n      gl.bindTexture(gl.TEXTURE_2D, this.paletteTex);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      gl.activeTexture(gl.TEXTURE0);\n    }\n\n    this.paletteSize = size;\n    this.paletteTexW = texW;\n    this.paletteTexH = texH;\n\n    // Upload texture\n    gl.activeTexture(gl.TEXTURE0 + this.paletteTexUnit);\n    gl.bindTexture(gl.TEXTURE_2D, this.paletteTex);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, texW, texH, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.paletteBytes);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.activeTexture(gl.TEXTURE0);\n\n    // Upload uniforms to both palette programs; uniforms persist per-program.\n    const upload = (p: typeof this.pointsCircle | typeof this.pointsSquare) => {\n      if (!p) return;\n      gl.useProgram(p.program);\n      if (p.uPaletteTex) gl.uniform1i(p.uPaletteTex, this.paletteTexUnit);\n      if (p.uPaletteSize) gl.uniform1i(p.uPaletteSize, this.paletteSize);\n      if (p.uPaletteWidth) gl.uniform1i(p.uPaletteWidth, this.paletteTexW);\n    };\n\n    upload(this.pointsCircle);\n    upload(this.pointsSquare);\n\n    this.paletteDirty = false;\n  }\n\n  protected bindPaletteTexture(): void {\n    const gl = this.gl;\n    if (!gl || !this.paletteTex) return;\n    gl.activeTexture(gl.TEXTURE0 + this.paletteTexUnit);\n    gl.bindTexture(gl.TEXTURE_2D, this.paletteTex);\n    // Restore predictable state for resource alloc helpers.\n    gl.activeTexture(gl.TEXTURE0);\n  }\n\n  async countSelection(result: SelectionResult, opts: CountSelectionOptions = {}): Promise<number> {\n    const ds = this.dataset;\n    const idx = this.dataIndex;\n    if (!ds || !idx) return 0;\n\n    if (result.indices) return result.indices.size;\n    if (result.kind !== 'geometry' || !result.geometry) return 0;\n\n    const polygon = result.geometry.coords;\n    const nPoly = polygon.length / 2;\n    if (nPoly < 3) return 0;\n\n    // Bounds are usually attached by the candidate lassoSelect(). Compute as\n    // a fallback to keep this method robust.\n    let bounds = result.geometry.bounds;\n    if (!bounds) {\n      let xMin = Infinity;\n      let yMin = Infinity;\n      let xMax = -Infinity;\n      let yMax = -Infinity;\n      for (let i = 0; i < polygon.length; i += 2) {\n        const x = polygon[i];\n        const y = polygon[i + 1];\n        if (x < xMin) xMin = x;\n        if (x > xMax) xMax = x;\n        if (y < yMin) yMin = y;\n        if (y > yMax) yMax = y;\n      }\n      bounds = { xMin, yMin, xMax, yMax };\n    }\n\n    const shouldCancel = opts.shouldCancel;\n    const onProgress = opts.onProgress;\n    const yieldEveryMs = (typeof opts.yieldEveryMs === 'number' && Number.isFinite(opts.yieldEveryMs))\n      ? Math.max(0, opts.yieldEveryMs)\n      : 8;\n\n    const eps = 1e-12;\n    const minX = bounds.xMin - eps;\n    const minY = bounds.yMin - eps;\n    const maxX = bounds.xMax + eps;\n    const maxY = bounds.yMax + eps;\n\n    const clampInt = (v: number, lo: number, hi: number): number => {\n      if (v < lo) return lo;\n      if (v > hi) return hi;\n      return v | 0;\n    };\n\n    const cx0 = clampInt(Math.floor((minX - idx.bounds.minX) / idx.cellSizeX), 0, idx.cellsX - 1);\n    const cy0 = clampInt(Math.floor((minY - idx.bounds.minY) / idx.cellSizeY), 0, idx.cellsY - 1);\n    const cx1 = clampInt(Math.floor((maxX - idx.bounds.minX) / idx.cellSizeX), 0, idx.cellsX - 1);\n    const cy1 = clampInt(Math.floor((maxY - idx.bounds.minY) / idx.cellSizeY), 0, idx.cellsY - 1);\n\n    const positions = ds.positions;\n    const ids = idx.ids;\n    const offsets = idx.offsets;\n\n    let selected = 0;\n    let processed = 0;\n\n    const CHECK_STRIDE = 16_384;\n    let nextCheck = CHECK_STRIDE;\n    let lastYieldTs = yieldEveryMs > 0 ? performance.now() : 0;\n\n    for (let cy = cy0; cy <= cy1; cy++) {\n      const rowBase = cy * idx.cellsX;\n      for (let cx = cx0; cx <= cx1; cx++) {\n        const cell = rowBase + cx;\n        const start = offsets[cell];\n        const end = offsets[cell + 1];\n        for (let k = start; k < end; k++) {\n          const i = ids[k];\n          const x = positions[i * 2];\n          const y = positions[i * 2 + 1];\n\n          // Tight AABB prefilter (cells overlap bounds).\n          if (x < bounds.xMin || x > bounds.xMax || y < bounds.yMin || y > bounds.yMax) continue;\n\n          if (pointInPolygon(x, y, polygon)) selected++;\n          processed++;\n\n          if (yieldEveryMs > 0 && processed >= nextCheck) {\n            nextCheck = processed + CHECK_STRIDE;\n\n            if (shouldCancel?.()) return selected;\n\n            const now = performance.now();\n            if (now - lastYieldTs >= yieldEveryMs) {\n              onProgress?.(selected, processed);\n              await new Promise<void>((resolve) => requestAnimationFrame(() => resolve()));\n              lastYieldTs = performance.now();\n            }\n          }\n        }\n      }\n    }\n\n    onProgress?.(selected, processed);\n    return selected;\n  }\n\n  // ==== Required interaction methods (abstracts for math) ==== \n\n  abstract pan(deltaX: number, deltaY: number, modifiers: Modifiers): void;\n  abstract zoom(anchorX: number, anchorY: number, delta: number, modifiers: Modifiers): void;\n  abstract hitTest(screenX: number, screenY: number): HitResult | null;\n  abstract lassoSelect(polyline: Float32Array): SelectionResult;\n  abstract projectToScreen(dataX: number, dataY: number): { x: number; y: number };\n  abstract unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number };\n\n  // ==== GPU ==== \n\n  protected abstract geometryKind(): GeometryKind;\n\n  protected ensureGL(): void {\n    if (this.gl) return;\n    if (!this.canvas) throw new Error('Renderer not initialized');\n\n    // Now that we actually intend to render with WebGL, we can safely size the\n    // canvas drawing buffer.\n    // Keep final canvas at device DPR for reference-like background quality.\n    setCanvasSize(this.canvas, this.width, this.height, this.canvasDpr);\n\n    const gl = this.canvas.getContext('webgl2', {\n      // MSAA improves point sprite edge quality (less \"squarish\" at small sizes).\n      // This is especially noticeable for Euclidean where points are drawn all over\n      // the canvas and your eye picks up aliasing more easily.\n      // But it can cost noticeable fill-rate at very large N, so keep it off\n      // and rely on shader-based AA instead.\n      antialias: false,\n      // Keep opaque for performance; we render the hyperbolic backdrop in WebGL.\n      alpha: false,\n      depth: false,\n      stencil: false,\n      preserveDrawingBuffer: false,\n      premultipliedAlpha: false,\n      desynchronized: true,\n    } as WebGLContextAttributes);\n\n    if (!gl) {\n      throw new Error('Failed to get WebGL2 context (is the canvas already using 2D context?)');\n    }\n\n    this.gl = gl;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    // Enable blending so anti-aliased point edges can blend with the background.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    const [br, bg, bb, ba] = parseHexColor(this.backgroundColor);\n    gl.clearColor(br, bg, bb, ba);\n\n    gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n    this.createProgramsAndBuffers();\n\n    // Upload palette uniforms once after program creation.\n    this.uploadPaletteUniforms();\n\n    if (this.dataset) {\n      this.uploadDatasetToGPU();\n    }\n    this.uploadSelectionToGPU();\n    this.uploadHoverToGPU();\n\n    // Backdrop depends on size/zoom.\n    this.markBackdropDirty();\n  }\n\n  protected ensurePointsResources(): void {\n    if (!this.gl || !this.canvas) return;\n    const gl = this.gl;\n\n    // Points buffer size at adaptive DPR.\n    let w = Math.max(1, Math.floor(this.width * this.dpr));\n    let h = Math.max(1, Math.floor(this.height * this.dpr));\n\n    const maxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE) as number;\n    if (w > maxTex || h > maxTex) {\n      const s = Math.min(1, maxTex / w, maxTex / h);\n      w = Math.max(1, Math.floor(w * s));\n      h = Math.max(1, Math.floor(h * s));\n    }\n\n    if (!this.pointsTex) {\n      this.pointsTex = gl.createTexture();\n      if (!this.pointsTex) throw new Error('Failed to create points texture');\n      gl.bindTexture(gl.TEXTURE_2D, this.pointsTex);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    if (!this.pointsFbo) {\n      this.pointsFbo = gl.createFramebuffer();\n      if (!this.pointsFbo) throw new Error('Failed to create points framebuffer');\n    }\n\n    if (w !== this.pointsW || h !== this.pointsH) {\n      this.pointsW = w;\n      this.pointsH = h;\n\n      gl.bindTexture(gl.TEXTURE_2D, this.pointsTex);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.pointsFbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pointsTex, 0);\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error(`Points framebuffer incomplete: ${status}`);\n      }\n    }\n  }\n\n  protected ensureBackdropResources(): void {\n    if (!this.gl || !this.canvas) return;\n    if (this.geometryKind() !== 'poincare') return;\n    if (!this.poincareDisk || !this.vao) return;\n\n    const gl = this.gl;\n\n    // Render backdrop at full canvas DPR so thin grid lines survive.\n    const desiredDpr = Math.max(1, this.canvasDpr);\n    let w = Math.max(1, Math.floor(this.width * desiredDpr));\n    let h = Math.max(1, Math.floor(this.height * desiredDpr));\n\n    const maxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE) as number;\n    if (w > maxTex || h > maxTex) {\n      const s = Math.min(1, maxTex / w, maxTex / h);\n      w = Math.max(1, Math.floor(w * s));\n      h = Math.max(1, Math.floor(h * s));\n      this.backdropDpr = desiredDpr * s;\n    } else {\n      this.backdropDpr = desiredDpr;\n    }\n\n    if (!this.backdropTex) {\n      this.backdropTex = gl.createTexture();\n      if (!this.backdropTex) throw new Error('Failed to create backdrop texture');\n      gl.bindTexture(gl.TEXTURE_2D, this.backdropTex);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    if (!this.backdropFbo) {\n      this.backdropFbo = gl.createFramebuffer();\n      if (!this.backdropFbo) throw new Error('Failed to create backdrop framebuffer');\n    }\n\n    if (w !== this.backdropW || h !== this.backdropH) {\n      this.backdropW = w;\n      this.backdropH = h;\n\n      gl.bindTexture(gl.TEXTURE_2D, this.backdropTex);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.backdropFbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.backdropTex, 0);\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error(`Backdrop framebuffer incomplete: ${status}`);\n      }\n\n      this.markBackdropDirty();\n    }\n  }\n\n  protected renderBackdropIfNeeded(): void {\n    if (!this.gl || !this.canvas) return;\n    if (this.geometryKind() !== 'poincare') return;\n    if (!this.poincareDisk || !this.vao) return;\n\n    this.ensureBackdropResources();\n    if (!this.backdropFbo) return;\n\n    const zoom = this.getBackdropZoom();\n    const zoomSame = Number.isFinite(this.backdropZoom) && Math.abs(this.backdropZoom - zoom) <= 1e-12;\n    if (!this.backdropDirty && zoomSame) return;\n\n    const gl = this.gl;\n\n    // Render disk+grid into texture.\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.backdropFbo);\n    gl.viewport(0, 0, this.backdropW, this.backdropH);\n\n    const [br, bg, bb, ba] = parseHexColor(this.backgroundColor);\n    gl.clearColor(br, bg, bb, ba);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.useProgram(this.poincareDisk.program);\n    this.bindViewUniformsForProgram(this.poincareDisk.program);\n    this.uploadPoincareDiskStyleUniforms();\n    if (this.poincareDisk.uCssSize) gl.uniform2f(this.poincareDisk.uCssSize, this.width, this.height);\n    if (this.poincareDisk.uDpr) gl.uniform1f(this.poincareDisk.uDpr, this.backdropDpr);\n    gl.bindVertexArray(this.vao);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    // Restore default framebuffer + viewport.\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n    this.backdropZoom = zoom;\n    this.backdropDirty = false;\n  }\n\n  protected createProgramsAndBuffers(): void {\n    const gl = this.gl!;\n\n    const vs = this.geometryKind() === 'euclidean' ? VS_EUCLIDEAN : VS_POINCARE;\n\n    // Programs\n    const circleProgram = linkProgram(gl, vs, FS_POINTS);\n    const squareProgram = linkProgram(gl, vs, FS_POINTS_SQUARE);\n    this.programSolid = linkProgram(gl, vs, FS_SOLID);\n\n    // Composite program (fullscreen textured triangle)\n    this.programComposite = linkProgram(gl, VS_FULLSCREEN, FS_COMPOSITE);\n    gl.useProgram(this.programComposite);\n    this.uCompositeTex = gl.getUniformLocation(this.programComposite, 'u_tex');\n\n    // Poincaré disk background (only for hyperbolic)\n    if (this.geometryKind() === 'poincare') {\n      const diskProgram = linkProgram(gl, VS_FULLSCREEN, FS_POINCARE_DISK);\n      this.poincareDisk = {\n        program: diskProgram,\n        uCssSize: gl.getUniformLocation(diskProgram, 'u_cssSize'),\n        uDpr: gl.getUniformLocation(diskProgram, 'u_dpr'),\n        uDiskFillColor: gl.getUniformLocation(diskProgram, 'u_diskFillColor'),\n        uDiskBorderColor: gl.getUniformLocation(diskProgram, 'u_diskBorderColor'),\n        uGridColor: gl.getUniformLocation(diskProgram, 'u_gridColor'),\n        uDiskBorderWidthPx: gl.getUniformLocation(diskProgram, 'u_diskBorderWidthPx'),\n        uGridWidthPx: gl.getUniformLocation(diskProgram, 'u_gridWidthPx'),\n      };\n\n      // Upload style uniforms once; they persist for this program.\n      gl.useProgram(diskProgram);\n      this.uploadPoincareDiskStyleUniforms();\n    }\n\n    // Points pipeline (circle)\n    gl.useProgram(circleProgram);\n    this.pointsCircle = {\n      program: circleProgram,\n      uPaletteTex: gl.getUniformLocation(circleProgram, 'u_paletteTex'),\n      uPaletteSize: gl.getUniformLocation(circleProgram, 'u_paletteSize'),\n      uPaletteWidth: gl.getUniformLocation(circleProgram, 'u_paletteWidth'),\n      uCssSize: gl.getUniformLocation(circleProgram, 'u_cssSize'),\n      uDpr: gl.getUniformLocation(circleProgram, 'u_dpr'),\n      uPointRadius: gl.getUniformLocation(circleProgram, 'u_pointRadiusCss'),\n    };\n\n    // Points pipeline (square)\n    gl.useProgram(squareProgram);\n    this.pointsSquare = {\n      program: squareProgram,\n      uPaletteTex: gl.getUniformLocation(squareProgram, 'u_paletteTex'),\n      uPaletteSize: gl.getUniformLocation(squareProgram, 'u_paletteSize'),\n      uPaletteWidth: gl.getUniformLocation(squareProgram, 'u_paletteWidth'),\n      uCssSize: gl.getUniformLocation(squareProgram, 'u_cssSize'),\n      uDpr: gl.getUniformLocation(squareProgram, 'u_dpr'),\n      uPointRadius: gl.getUniformLocation(squareProgram, 'u_pointRadiusCss'),\n    };\n\n    // Uniform locations (solid)\n    gl.useProgram(this.programSolid);\n    this.uSolidColor = gl.getUniformLocation(this.programSolid, 'u_color');\n    this.uSolidPointSizePx = gl.getUniformLocation(this.programSolid, 'u_pointSizePx');\n    this.uSolidRingThicknessPx = gl.getUniformLocation(this.programSolid, 'u_ringThicknessPx');\n    this.uSolidRingMode = gl.getUniformLocation(this.programSolid, 'u_ringMode');\n    this.uCssSizeSolid = gl.getUniformLocation(this.programSolid, 'u_cssSize');\n    this.uDprSolid = gl.getUniformLocation(this.programSolid, 'u_dpr');\n    this.uPointRadiusSolid = gl.getUniformLocation(this.programSolid, 'u_pointRadiusCss');\n\n    // Buffers + VAO\n    this.vao = gl.createVertexArray();\n    this.posBuffer = gl.createBuffer();\n    this.labelBuffer = gl.createBuffer();\n\n    // Overlay VAOs/buffers\n    this.hoverVao = gl.createVertexArray();\n    this.hoverPosBuffer = gl.createBuffer();\n    this.hoverLabelBuffer = gl.createBuffer();\n\n    this.selectionVao = gl.createVertexArray();\n    this.selectionPosBuffer = gl.createBuffer();\n    this.selectionLabelBuffer = gl.createBuffer();\n\n    this.selectionEbo = gl.createBuffer();\n    this.hoverEbo = gl.createBuffer();\n    this.interactionEbo = gl.createBuffer();\n\n    if (!this.vao || !this.posBuffer || !this.labelBuffer ||\n        !this.hoverVao || !this.hoverPosBuffer || !this.hoverLabelBuffer ||\n        !this.selectionVao || !this.selectionPosBuffer || !this.selectionLabelBuffer ||\n        !this.selectionEbo || !this.hoverEbo || !this.interactionEbo) {\n      throw new Error('Failed to allocate WebGL resources');\n    }\n\n    gl.bindVertexArray(this.vao);\n\n    // Positions (vec2)\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n\n    // Labels (uint)\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.labelBuffer);\n    gl.enableVertexAttribArray(1);\n    gl.vertexAttribIPointer(1, 1, gl.UNSIGNED_SHORT, 0, 0);\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    // Hover VAO (single point)\n    gl.bindVertexArray(this.hoverVao);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.hoverPosBuffer);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.hoverLabelBuffer);\n    gl.enableVertexAttribArray(1);\n    gl.vertexAttribIPointer(1, 1, gl.UNSIGNED_SHORT, 0, 0);\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    // Selection VAO (N points)\n    gl.bindVertexArray(this.selectionVao);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.selectionPosBuffer);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.selectionLabelBuffer);\n    gl.enableVertexAttribArray(1);\n    gl.vertexAttribIPointer(1, 1, gl.UNSIGNED_SHORT, 0, 0);\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected uploadDatasetToGPU(): void {\n    const gl = this.gl!;\n    const ds = this.dataset;\n    if (!ds) return;\n\n    gl.bindVertexArray(this.vao);\n\n    // Decide whether to upload the full dataset or only a deterministic subsample.\n    // NOTE: CPU-side interaction (hitTest/lasso) always uses the full dataset.\n    const useFullUpload = ds.n <= this.maxGpuUploadPoints;\n    this.gpuUsesFullDataset = useFullUpload;\n\n    if (useFullUpload) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, ds.positions, gl.STATIC_DRAW);\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.labelBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, ds.labels, gl.STATIC_DRAW);\n\n      this.gpuPointCount = ds.n;\n    } else {\n      const n = ds.n;\n      const target = Math.min(n, Math.max(250_000, Math.min(this.maxBaseDrawPoints, Math.floor(n * 0.25))));\n      const step = Math.max(1, Math.floor(n / target));\n      const count = Math.min(target, Math.ceil(n / step));\n\n      const subPos = new Float32Array(count * 2);\n      const subLab = new Uint16Array(count);\n      let k = 0;\n      for (let i = 0; i < n && k < count; i += step) {\n        subPos[k * 2] = ds.positions[i * 2];\n        subPos[k * 2 + 1] = ds.positions[i * 2 + 1];\n        subLab[k] = ds.labels[i];\n        k++;\n      }\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, subPos, gl.STATIC_DRAW);\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.labelBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, subLab, gl.STATIC_DRAW);\n\n      this.gpuPointCount = k;\n    }\n\n    // Precompute a deterministic, globally distributed subsample for LOD.\n    // This is used during interaction (to keep panning smooth), and also as an\n    // always-on cap for very large N where drawing every point every frame is\n    // not realistic.\n    this.interactionCount = 0;\n    if (this.interactionEbo && this.gpuUsesFullDataset) {\n      const n = ds.n;\n      if (n >= 500_000) {\n        // Keep enough points for a faithful density impression, but avoid\n        // unbounded vertex cost.\n        const target = Math.min(n, Math.max(250_000, Math.min(this.maxBaseDrawPoints, Math.floor(n * 0.25))));\n        const step = Math.max(1, Math.floor(n / target));\n        const count = Math.min(target, Math.ceil(n / step));\n        const indices = new Uint32Array(count);\n        let k = 0;\n        for (let i = 0; i < n && k < count; i += step) {\n          indices[k++] = i;\n        }\n        this.interactionCount = k;\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.interactionEbo);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      }\n    }\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected uploadSelectionToGPU(): void {\n    if (!this.gl || !this.selectionEbo) return;\n    const gl = this.gl;\n\n    // Rendering selection overlays for millions of points is both expensive and\n    // memory-heavy (index buffers / position buffers). We keep the selection\n    // semantics exact, but cap the *rendered* overlay for practicality.\n    const MAX_RENDER_SELECTION = 250_000;\n\n    if (!this.gpuUsesFullDataset) {\n      const ds = this.dataset;\n      if (!ds || !this.selectionVao || !this.selectionPosBuffer || !this.selectionLabelBuffer) return;\n\n      const count = this.selection.size;\n      this.selectionOverlayCount = Math.min(count, MAX_RENDER_SELECTION);\n      if (count === 0) {\n        this.selectionDirty = false;\n        return;\n      }\n\n      // For huge selections, render only a deterministic prefix (iteration\n      // order of Set is deterministic for a fixed construction).\n      const renderCount = Math.min(count, MAX_RENDER_SELECTION);\n      const pos = new Float32Array(renderCount * 2);\n      const lab = new Uint16Array(renderCount);\n      let k = 0;\n      for (const i of this.selection) {\n        pos[k * 2] = ds.positions[i * 2];\n        pos[k * 2 + 1] = ds.positions[i * 2 + 1];\n        lab[k] = ds.labels[i];\n        k++;\n        if (k >= renderCount) break;\n      }\n\n      this.selectionOverlayCount = k;\n\n      gl.bindVertexArray(this.selectionVao);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.selectionPosBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.selectionLabelBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, lab, gl.DYNAMIC_DRAW);\n      gl.bindVertexArray(null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n      this.selectionDirty = false;\n      return;\n    }\n\n    // Pack selection indices to Uint32 element buffer.\n    const count = this.selection.size;\n    const renderCount = Math.min(count, MAX_RENDER_SELECTION);\n    this.selectionOverlayCount = renderCount;\n    if (renderCount === 0) {\n      this.selectionDirty = false;\n      return;\n    }\n\n    const indices = new Uint32Array(renderCount);\n    let k = 0;\n    for (const i of this.selection) {\n      indices[k++] = i;\n      if (k >= renderCount) break;\n    }\n\n    this.selectionOverlayCount = k;\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.selectionEbo);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.DYNAMIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n    this.selectionDirty = false;\n  }\n\n  protected uploadHoverToGPU(): void {\n    if (!this.gl || !this.hoverEbo) return;\n    const gl = this.gl;\n\n    if (!this.gpuUsesFullDataset) {\n      const ds = this.dataset;\n      if (!ds || !this.hoverVao || !this.hoverPosBuffer || !this.hoverLabelBuffer) return;\n\n      const i = (this.hoveredIndex >= 0 && this.hoveredIndex < ds.n) ? this.hoveredIndex : -1;\n      const pos = this.hoverPosScratch;\n      const lab = this.hoverLabScratch;\n      if (i >= 0) {\n        pos[0] = ds.positions[i * 2];\n        pos[1] = ds.positions[i * 2 + 1];\n        lab[0] = ds.labels[i];\n      } else {\n        pos[0] = 2;\n        pos[1] = 2;\n        lab[0] = 0;\n      }\n\n      gl.bindVertexArray(this.hoverVao);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.hoverPosBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.hoverLabelBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, lab, gl.DYNAMIC_DRAW);\n      gl.bindVertexArray(null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n      this.hoverDirty = false;\n      return;\n    }\n\n    const idx = this.hoveredIndex >= 0 ? this.hoveredIndex : 0;\n    const indices = this.hoverIndexScratch;\n    indices[0] = idx;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.hoverEbo);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.DYNAMIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n    this.hoverDirty = false;\n  }\n\n  // Implemented per-geometry (uniform sets)\n  protected abstract bindViewUniformsForProgram(program: WebGLProgram): void;\n\n  render(): void {\n    this.ensureGL();\n\n    const gl = this.gl!;\n    const ds = this.dataset;\n    if (!ds) return;\n\n    // During active interaction (pan/zoom), hyperbolic rendering can become\n    // vertex-transform bound at 1M points. Temporarily draw fewer points to\n    // keep the interaction at (or near) 60 FPS, then restore full detail when\n    // the view stabilizes.\n    const now = performance.now();\n    const isInteracting = (now - this.lastViewChangeTs) < 80;\n    const hasLod = !!this.interactionEbo && this.interactionCount > 0;\n\n    // 1) Interaction LOD (primarily hyperbolic; vertex math is heavier)\n    // NOTE: For ~1M points the subsample->full switch can be perceptually jarring\n    // (a density \"pop\") even if the view state is correct. We therefore only\n    // enable interaction LOD above a higher threshold.\n    const interactionLodMinPoints = 2_000_000;\n    const useInteractionLod =\n      isInteracting &&\n      this.geometryKind() === 'poincare' &&\n      ds.n >= interactionLodMinPoints &&\n      hasLod;\n\n    // 2) Always-on LOD cap for very large datasets (both geometries)\n    // Apply regardless of interaction to avoid catastrophic pan/hover stalls\n    // on huge datasets (especially Euclidean).\n    const useLargeNLod =\n      ds.n > this.maxBaseDrawPoints &&\n      hasLod;\n\n    // If the main GPU buffers already contain a subsample, do not additionally\n    // apply EBO LOD.\n    const useLod = this.gpuUsesFullDataset && (useInteractionLod || useLargeNLod);\n\n    const baseDrawCount = this.gpuUsesFullDataset\n      ? (useLod ? this.interactionCount : ds.n)\n      : this.gpuPointCount;\n    const estimatedFragments = this.estimatePointFragments(baseDrawCount, this.dpr);\n    this.updateSquarePointPolicy(estimatedFragments);\n\n    if (this.selectionDirty) this.uploadSelectionToGPU();\n    if (this.hoverDirty) this.uploadHoverToGPU();\n\n    // Background (full-res)\n    // NOTE: We intentionally avoid gl.blitFramebuffer() here because it can\n    // fail (INVALID_OPERATION) depending on driver/default framebuffer\n    // constraints, leading to a missing disk/grid. Sampling the cached\n    // backdrop texture via a fullscreen draw is robust.\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvas!.width, this.canvas!.height);\n    gl.disable(gl.BLEND);\n\n    if (this.geometryKind() === 'poincare') {\n      this.renderBackdropIfNeeded();\n      if (this.backdropTex && this.programComposite) {\n        gl.useProgram(this.programComposite);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this.backdropTex);\n        if (this.uCompositeTex) gl.uniform1i(this.uCompositeTex, 0);\n        gl.bindVertexArray(this.vao);\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n      } else {\n        const [br, bg, bb, ba] = parseHexColor(this.backgroundColor);\n        gl.clearColor(br, bg, bb, ba);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    } else {\n      // Restore clearColor (may have been changed to transparent for offscreen FBO)\n      const [br, bg, bb, ba] = parseHexColor(this.backgroundColor);\n      gl.clearColor(br, bg, bb, ba);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    // Render points into low-res offscreen buffer.\n    this.ensurePointsResources();\n    if (!this.pointsFbo || !this.pointsTex || !this.programComposite) return;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.pointsFbo);\n    gl.viewport(0, 0, this.pointsW, this.pointsH);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Base points\n    // NOTE: WebGL points are square by default. We implement circles by discarding\n    // fragments outside the unit disk in the fragment shader (FS_POINTS).\n    // For extremely large point counts, using square points can be faster on\n    // some GPUs (no discard). However, it noticeably changes appearance.\n    //\n    // Heuristic: prefer circles up to a few million points.\n    const basePoints = this.renderAsSquares ? this.pointsSquare : this.pointsCircle;\n    if (!basePoints) return;\n\n    gl.useProgram(basePoints.program);\n    this.bindViewUniformsForProgram(basePoints.program);\n\n    // Palette uniforms are uploaded once per program.\n    if (this.paletteDirty) this.uploadPaletteUniforms();\n    this.bindPaletteTexture();\n\n    if (basePoints.uCssSize) gl.uniform2f(basePoints.uCssSize, this.width, this.height);\n    if (basePoints.uDpr) gl.uniform1f(basePoints.uDpr, this.dpr);\n    if (basePoints.uPointRadius) gl.uniform1f(basePoints.uPointRadius, this.pointRadiusCss);\n\n    // Optimization: Disable blending when rendering squares (performance mode).\n    // This avoids expensive read-modify-write operations for every pixel.\n    if (this.renderAsSquares) {\n      gl.disable(gl.BLEND);\n    } else {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    gl.bindVertexArray(this.vao);\n    if (useLod) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.interactionEbo);\n      gl.drawElements(gl.POINTS, this.interactionCount, gl.UNSIGNED_INT, 0);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    } else {\n      const count = this.gpuUsesFullDataset ? ds.n : this.gpuPointCount;\n      gl.drawArrays(gl.POINTS, 0, count);\n    }\n\n    // Expose policy snapshot (for benchmarks / diagnostics).\n    (this as any).__debugPolicy = {\n      pointsDpr: this.dpr,\n      deviceDpr: this.deviceDpr,\n      canvasDpr: this.canvasDpr,\n      renderAsSquares: this.renderAsSquares,\n      useLod,\n      baseDrawCount,\n      interactionCount: this.interactionCount,\n      gpuUsesFullDataset: this.gpuUsesFullDataset,\n      gpuPointCount: this.gpuPointCount,\n      estimatedPointFragments: estimatedFragments,\n      fragmentBudget: this.policy.fragmentBudget,\n      isInteracting,\n    };\n\n    // Selection overlay (still into points buffer)\n    if (!isInteracting && this.selection.size > 0) {\n      gl.useProgram(this.programSolid);\n      this.bindViewUniformsForProgram(this.programSolid!);\n\n      if (this.uCssSizeSolid) gl.uniform2f(this.uCssSizeSolid, this.width, this.height);\n      if (this.uDprSolid) gl.uniform1f(this.uDprSolid, this.dpr);\n      if (this.uPointRadiusSolid) gl.uniform1f(this.uPointRadiusSolid, this.pointRadiusCss + 1);\n\n      if (this.uSolidColor) {\n        const [r, g, b, a] = parseHexColor(SELECTION_COLOR);\n        gl.uniform4f(this.uSolidColor, r, g, b, a);\n      }\n      if (this.uSolidRingMode) gl.uniform1i(this.uSolidRingMode, 0);\n      if (this.uSolidRingThicknessPx) gl.uniform1f(this.uSolidRingThicknessPx, 0);\n      if (this.uSolidPointSizePx) gl.uniform1f(this.uSolidPointSizePx, (this.pointRadiusCss + 1) * 2 * this.dpr);\n\n      if (this.gpuUsesFullDataset) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.selectionEbo);\n        gl.drawElements(gl.POINTS, this.selectionOverlayCount, gl.UNSIGNED_INT, 0);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      } else if (this.selectionVao && this.selectionOverlayCount > 0) {\n        gl.bindVertexArray(this.selectionVao);\n        gl.drawArrays(gl.POINTS, 0, this.selectionOverlayCount);\n        gl.bindVertexArray(this.vao);\n      }\n    }\n\n    // Hover overlay (still into points buffer)\n    if (!isInteracting && this.hoveredIndex >= 0 && this.hoveredIndex < ds.n) {\n      // Ring\n      gl.useProgram(this.programSolid);\n      this.bindViewUniformsForProgram(this.programSolid!);\n\n      if (this.uCssSizeSolid) gl.uniform2f(this.uCssSizeSolid, this.width, this.height);\n      if (this.uDprSolid) gl.uniform1f(this.uDprSolid, this.dpr);\n\n      // Ring pass\n      const ringRadius = this.pointRadiusCss + 3;\n      if (this.uPointRadiusSolid) gl.uniform1f(this.uPointRadiusSolid, ringRadius);\n      if (this.uSolidColor) {\n        const [r, g, b, a] = parseHexColor(HOVER_COLOR);\n        gl.uniform4f(this.uSolidColor, r, g, b, a);\n      }\n      if (this.uSolidRingMode) gl.uniform1i(this.uSolidRingMode, 1);\n      if (this.uSolidRingThicknessPx) gl.uniform1f(this.uSolidRingThicknessPx, 2);\n      if (this.uSolidPointSizePx) gl.uniform1f(this.uSolidPointSizePx, ringRadius * 2 * this.dpr);\n\n      if (this.gpuUsesFullDataset) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.hoverEbo);\n        gl.drawElements(gl.POINTS, 1, gl.UNSIGNED_INT, 0);\n      } else if (this.hoverVao) {\n        gl.bindVertexArray(this.hoverVao);\n        gl.drawArrays(gl.POINTS, 0, 1);\n        gl.bindVertexArray(this.vao);\n      }\n\n      // Fill pass (selection color if selected else palette)\n      const fillRadius = this.pointRadiusCss + 1;\n      if (this.selection.has(this.hoveredIndex)) {\n        // Solid red\n        if (this.uPointRadiusSolid) gl.uniform1f(this.uPointRadiusSolid, fillRadius);\n        if (this.uSolidColor) {\n          const [r, g, b, a] = parseHexColor(SELECTION_COLOR);\n          gl.uniform4f(this.uSolidColor, r, g, b, a);\n        }\n        if (this.uSolidRingMode) gl.uniform1i(this.uSolidRingMode, 0);\n        if (this.uSolidRingThicknessPx) gl.uniform1f(this.uSolidRingThicknessPx, 0);\n        if (this.uSolidPointSizePx) gl.uniform1f(this.uSolidPointSizePx, fillRadius * 2 * this.dpr);\n        if (this.gpuUsesFullDataset) {\n          gl.drawElements(gl.POINTS, 1, gl.UNSIGNED_INT, 0);\n        } else if (this.hoverVao) {\n          gl.bindVertexArray(this.hoverVao);\n          gl.drawArrays(gl.POINTS, 0, 1);\n          gl.bindVertexArray(this.vao);\n        }\n      } else {\n        // Use palette program for correct label color\n        const circlePoints = this.pointsCircle;\n        if (!circlePoints) return;\n        gl.useProgram(circlePoints.program);\n        this.bindViewUniformsForProgram(circlePoints.program);\n        if (this.paletteDirty) this.uploadPaletteUniforms();\n        this.bindPaletteTexture();\n        if (circlePoints.uCssSize) gl.uniform2f(circlePoints.uCssSize, this.width, this.height);\n        if (circlePoints.uDpr) gl.uniform1f(circlePoints.uDpr, this.dpr);\n        if (circlePoints.uPointRadius) gl.uniform1f(circlePoints.uPointRadius, fillRadius);\n\n        if (this.gpuUsesFullDataset) {\n          gl.drawElements(gl.POINTS, 1, gl.UNSIGNED_INT, 0);\n        } else if (this.hoverVao) {\n          gl.bindVertexArray(this.hoverVao);\n          gl.drawArrays(gl.POINTS, 0, 1);\n          gl.bindVertexArray(this.vao);\n        }\n      }\n\n      if (this.gpuUsesFullDataset) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      }\n    }\n\n    // Composite points buffer onto full-res default framebuffer.\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvas!.width, this.canvas!.height);\n\n    gl.useProgram(this.programComposite);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.pointsTex);\n    if (this.uCompositeTex) gl.uniform1i(this.uCompositeTex, 0);\n\n    // Blend points over background.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.bindVertexArray(this.vao);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    // Restore point VAO for next frame.\n    gl.bindVertexArray(this.vao);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.bindVertexArray(null);\n  }\n}\n\n// ============================================================================\n// Euclidean candidate\n// ============================================================================\n\nexport class EuclideanWebGLCandidate extends WebGLRendererBase {\n  private view: EuclideanViewState = createEuclideanView();\n\n  private uniformCache = new Map<WebGLProgram, { uCenter: WebGLUniformLocation | null; uZoom: WebGLUniformLocation | null }>();\n\n  protected geometryKind(): GeometryKind {\n    return 'euclidean';\n  }\n\n  setDataset(dataset: Dataset): void {\n    if (dataset.geometry !== 'euclidean') {\n      throw new Error('EuclideanWebGLCandidate only supports euclidean geometry');\n    }\n    super.setDataset(dataset);\n    this.fitToData();\n  }\n\n  private fitToData(): void {\n    const ds = this.dataset;\n    if (!ds || ds.n === 0) return;\n\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (let i = 0; i < ds.n; i++) {\n      const x = ds.positions[i * 2];\n      const y = ds.positions[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    const dataWidth = maxX - minX || 1;\n    const dataHeight = maxY - minY || 1;\n    const dataSize = Math.max(dataWidth, dataHeight);\n    const fitZoom = 2 / dataSize;\n\n    this.view = {\n      type: 'euclidean',\n      centerX: (minX + maxX) / 2,\n      centerY: (minY + maxY) / 2,\n      zoom: Math.max(0.1, Math.min(100, fitZoom)),\n    };\n  }\n\n  setView(view: ViewState): void {\n    if (view.type !== 'euclidean') {\n      throw new Error('EuclideanWebGLCandidate only supports euclidean view state');\n    }\n    this.view = view;\n  }\n\n  getView(): ViewState {\n    return { ...this.view };\n  }\n\n  protected bindViewUniformsForProgram(program: WebGLProgram): void {\n    if (!this.gl) return;\n    const gl = this.gl;\n\n    let cached = this.uniformCache.get(program);\n    if (!cached) {\n      cached = {\n        uCenter: gl.getUniformLocation(program, 'u_center'),\n        uZoom: gl.getUniformLocation(program, 'u_zoom'),\n      };\n      this.uniformCache.set(program, cached);\n    }\n\n    if (cached.uCenter) gl.uniform2f(cached.uCenter, this.view.centerX, this.view.centerY);\n    if (cached.uZoom) gl.uniform1f(cached.uZoom, this.view.zoom);\n  }\n\n  pan(deltaX: number, deltaY: number, _modifiers: Modifiers): void {\n    this.view = panEuclidean(this.view, deltaX, deltaY, this.width, this.height);\n    this.markViewChanged();\n  }\n\n  zoom(anchorX: number, anchorY: number, delta: number, _modifiers: Modifiers): void {\n    this.view = zoomEuclidean(this.view, anchorX, anchorY, delta, this.width, this.height);\n    this.markViewChanged();\n  }\n\n  hitTest(screenX: number, screenY: number): HitResult | null {\n    const ds = this.dataset;\n    const idx = this.dataIndex;\n    if (!ds || !idx) return null;\n\n    // Reference hit radius rule\n    const maxDistPx = this.pointRadiusCss + 5;\n    const maxDistSq = maxDistPx * maxDistPx;\n\n    const scale = Math.min(this.width, this.height) * 0.4 * this.view.zoom;\n    if (!(scale > 0)) return null;\n\n    // Convert hit radius to data space.\n    // Add a tiny epsilon to avoid rare edge-case misses due to floating-point rounding.\n    const dataRadius = (maxDistPx / scale) * (1 + 1e-12);\n    const maxDataDistSq = dataRadius * dataRadius;\n\n    const dataPt = unprojectEuclidean(screenX, screenY, this.view, this.width, this.height);\n\n    // Inline projection math in the loop to avoid allocating {x,y} objects.\n    // We still compute exact screen-space distance for correctness.\n    const cx = this.width * 0.5;\n    const cy = this.height * 0.5;\n    const cX = this.view.centerX;\n    const cY = this.view.centerY;\n\n    let bestIndex = -1;\n    let bestDistSq = Infinity;\n\n    // Avoid building a potentially large candidates array (push-heavy).\n    // Instead iterate overlapping grid cells directly.\n    idx.forEachInAABB(\n      dataPt.x - dataRadius,\n      dataPt.y - dataRadius,\n      dataPt.x + dataRadius,\n      dataPt.y + dataRadius,\n      (i) => {\n        const dataX = ds.positions[i * 2];\n        const dataY = ds.positions[i * 2 + 1];\n\n        // Fast reject in data space (equivalent up to scale).\n        const dxData = dataX - dataPt.x;\n        const dyData = dataY - dataPt.y;\n        const dataDistSq = dxData * dxData + dyData * dyData;\n        if (dataDistSq > maxDataDistSq) return;\n\n        const sx = cx + (dataX - cX) * scale;\n        const sy = cy - (dataY - cY) * scale;\n        const dx = sx - screenX;\n        const dy = sy - screenY;\n        const distSq = dx * dx + dy * dy;\n\n        if (distSq <= maxDistSq) {\n          if (distSq < bestDistSq || (distSq === bestDistSq && i < bestIndex)) {\n            bestDistSq = distSq;\n            bestIndex = i;\n          }\n        }\n      },\n    );\n\n    if (bestIndex < 0) return null;\n\n    const bx = ds.positions[bestIndex * 2];\n    const by = ds.positions[bestIndex * 2 + 1];\n    const screen = projectEuclidean(bx, by, this.view, this.width, this.height);\n\n    return {\n      index: bestIndex,\n      screenX: screen.x,\n      screenY: screen.y,\n      distance: Math.sqrt(bestDistSq),\n    };\n  }\n\n  lassoSelect(polyline: Float32Array): SelectionResult {\n    const ds = this.dataset;\n    const idx = this.dataIndex;\n    if (!ds || !idx) return createIndicesSelectionResult(new Set(), 0);\n\n    const startTime = performance.now();\n\n    // Always return geometry (Embedding Atlas style). The UI/benchmarks should\n    // use Renderer.countSelection(...) to obtain counts efficiently.\n\n    const dataPolyline = new Float32Array(polyline.length);\n    for (let i = 0; i < polyline.length / 2; i++) {\n      const sx = polyline[i * 2];\n      const sy = polyline[i * 2 + 1];\n      const data = unprojectEuclidean(sx, sy, this.view, this.width, this.height);\n      dataPolyline[i * 2] = data.x;\n      dataPolyline[i * 2 + 1] = data.y;\n    }\n\n    // Tight AABB for fast reject in has() and efficient indexed counting.\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < dataPolyline.length; i += 2) {\n      const x = dataPolyline[i];\n      const y = dataPolyline[i + 1];\n      if (x < minX) minX = x;\n      if (x > maxX) maxX = x;\n      if (y < minY) minY = y;\n      if (y > maxY) maxY = y;\n    }\n\n    const bounds = { xMin: minX, yMin: minY, xMax: maxX, yMax: maxY };\n    const geometry: SelectionGeometry = { type: 'polygon', coords: dataPolyline, bounds };\n    const computeTimeMs = performance.now() - startTime;\n    return createGeometrySelectionResult(\n      geometry,\n      ds.positions,\n      computeTimeMs,\n      (px, py, polygon) => {\n        if (px < bounds.xMin || px > bounds.xMax || py < bounds.yMin || py > bounds.yMax) return false;\n        return pointInPolygon(px, py, polygon);\n      }\n    );\n  }\n\n  projectToScreen(dataX: number, dataY: number): { x: number; y: number } {\n    return projectEuclidean(dataX, dataY, this.view, this.width, this.height);\n  }\n\n  unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number } {\n    return unprojectEuclidean(screenX, screenY, this.view, this.width, this.height);\n  }\n}\n\n// ============================================================================\n// Hyperbolic candidate\n// ============================================================================\n\nexport class HyperbolicWebGLCandidate extends WebGLRendererBase {\n  private view: HyperbolicViewState = createHyperbolicView();\n\n  private uniformCache = new Map<WebGLProgram, { uA: WebGLUniformLocation | null; uDisplayZoom: WebGLUniformLocation | null }>();\n\n  // Pan tracking (same as reference)\n  private lastPanScreenX = 0;\n  private lastPanScreenY = 0;\n  private hasPanAnchor = false;\n\n  protected geometryKind(): GeometryKind {\n    return 'poincare';\n  }\n\n  protected override getBackdropZoom(): number {\n    return this.view.displayZoom;\n  }\n\n  setDataset(dataset: Dataset): void {\n    if (dataset.geometry !== 'poincare') {\n      throw new Error('HyperbolicWebGLCandidate only supports poincare geometry');\n    }\n    super.setDataset(dataset);\n    this.view = createHyperbolicView();\n\n    this.hasPanAnchor = false;\n  }\n\n  setView(view: ViewState): void {\n    if (view.type !== 'poincare') {\n      throw new Error('HyperbolicWebGLCandidate only supports poincare view state');\n    }\n    this.view = view;\n    this.markBackdropDirty();\n  }\n\n  getView(): ViewState {\n    return { ...this.view };\n  }\n\n  protected bindViewUniformsForProgram(program: WebGLProgram): void {\n    if (!this.gl) return;\n    const gl = this.gl;\n\n    let cached = this.uniformCache.get(program);\n    if (!cached) {\n      cached = {\n        uA: gl.getUniformLocation(program, 'u_a'),\n        uDisplayZoom: gl.getUniformLocation(program, 'u_displayZoom'),\n      };\n      this.uniformCache.set(program, cached);\n    }\n\n    if (cached.uA) gl.uniform2f(cached.uA, this.view.ax, this.view.ay);\n    if (cached.uDisplayZoom) gl.uniform1f(cached.uDisplayZoom, this.view.displayZoom);\n  }\n\n  // For accuracy harness: called via reflection if present.\n  startPan(screenX: number, screenY: number): void {\n    this.lastPanScreenX = screenX;\n    this.lastPanScreenY = screenY;\n    this.hasPanAnchor = true;\n  }\n\n  pan(deltaX: number, deltaY: number, _modifiers: Modifiers): void {\n    if (!this.hasPanAnchor) {\n      this.lastPanScreenX = this.width / 2;\n      this.lastPanScreenY = this.height / 2;\n      this.hasPanAnchor = true;\n    }\n\n    const startX = this.lastPanScreenX;\n    const startY = this.lastPanScreenY;\n    const endX = startX + deltaX;\n    const endY = startY + deltaY;\n\n    this.view = panPoincare(this.view, startX, startY, endX, endY, this.width, this.height);\n\n    this.markViewChanged();\n\n    this.lastPanScreenX = endX;\n    this.lastPanScreenY = endY;\n  }\n\n  zoom(anchorX: number, anchorY: number, delta: number, _modifiers: Modifiers): void {\n    this.view = zoomPoincare(this.view, anchorX, anchorY, delta, this.width, this.height);\n    this.markViewChanged();\n    this.markBackdropDirty();\n  }\n\n  private mobiusDerivativeScaleAt(zx: number, zy: number): number {\n    // For T_a(z) = (z - a) / (1 - conj(a) z), the conformal scale factor is:\n    // |T'_a(z)| = (1 - |a|^2) / |1 - conj(a) z|^2\n    const ax = this.view.ax;\n    const ay = this.view.ay;\n    const a2 = ax * ax + ay * ay;\n    const denomX = 1.0 - (ax * zx + ay * zy);\n    const denomY = -(ax * zy - ay * zx);\n    const denomNormSq = denomX * denomX + denomY * denomY;\n    if (denomNormSq < 1e-12) return 0;\n    const num = Math.max(0, 1.0 - a2);\n    return num / denomNormSq;\n  }\n\n  /**\n   * Compute a conservative Euclidean data-space radius that guarantees we won't\n   * miss any point within `screenRadiusPx` of the cursor.\n   *\n   * Derivation:\n   * - Screen-space displacement is (locally) scaled by:\n   *     localScale(z) = diskRadius * |T'_a(z)|\n   *   where T_a is the Möbius transform used by the camera.\n   * - |T'_a(z)| = (1 - |a|^2) / |1 - conj(a) z|^2.\n   * - Over a Euclidean ball |z - z0| <= r, the denominator norm is Lipschitz:\n   *     | |1 - conj(a)z| - |1 - conj(a)z0| | <= |a| * r\n   *   hence for any z in the ball:\n   *     |1 - conj(a)z| <= D0 + |a| r\n   *   which yields a lower bound on |T'_a(z)| (worst-case smallest scale).\n   *\n   * We solve the fixed point:\n   *   r = screenRadiusPx / (diskRadius * min|T'_a|)\n   *     = screenRadiusPx * (D0 + |a| r)^2 / (diskRadius * (1 - |a|^2))\n   * by a few iterations (converges quickly for |a|<1).\n   */\n  private conservativeDataRadiusForScreenRadius(\n    zx: number,\n    zy: number,\n    screenRadiusPx: number,\n    diskRadius: number\n  ): number {\n    const ax = this.view.ax;\n    const ay = this.view.ay;\n    const a2 = ax * ax + ay * ay;\n    const aMag = Math.sqrt(a2);\n\n    const C = Math.max(1e-12, 1.0 - a2);\n    if (!(diskRadius > 1e-9) || !(screenRadiusPx > 0)) return 0;\n\n    // D0 = |1 - conj(a) z0|\n    const denomX0 = 1.0 - (ax * zx + ay * zy);\n    const denomY0 = -(ax * zy - ay * zx);\n    const D0 = Math.sqrt(denomX0 * denomX0 + denomY0 * denomY0);\n    if (!Number.isFinite(D0) || D0 < 1e-12) return 2.0;\n\n    const K = screenRadiusPx / (diskRadius * C);\n    let r = K * D0 * D0;\n\n    // Fixed-point iterations. 4-5 is plenty.\n    for (let it = 0; it < 5; it++) {\n      const D = D0 + aMag * r;\n      r = K * D * D;\n    }\n\n    if (!Number.isFinite(r)) return 2.0;\n    // Tiny slack for floating point noise.\n    r *= 1.001;\n    return Math.min(1.999, Math.max(0, r));\n  }\n\n  hitTest(screenX: number, screenY: number): HitResult | null {\n    const ds = this.dataset;\n    const idx = this.dataIndex;\n    if (!ds || !idx) return null;\n\n    const { width, height, view } = this;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const diskRadius = Math.min(width, height) * 0.45 * view.displayZoom;\n    const diskR2 = diskRadius * diskRadius;\n\n    const maxDistPx = this.pointRadiusCss + 5;\n    const maxDistSq = maxDistPx * maxDistPx;\n\n    // Reference semantics: cursor may be outside the disk. We only cull points\n    // based on their *projected* position being outside the disk.\n    //\n    // However, if the cursor is far enough outside the disk that no point\n    // inside the disk could be within the hit radius, we can return null.\n    const dxCur = screenX - centerX;\n    const dyCur = screenY - centerY;\n    const maxCursorR = diskRadius + maxDistPx;\n    if (dxCur * dxCur + dyCur * dyCur > maxCursorR * maxCursorR) return null;\n\n    // Convert cursor to data space.\n    const dataPt = unprojectPoincare(screenX, screenY, view, width, height);\n    const queryRadius = this.conservativeDataRadiusForScreenRadius(\n      dataPt.x,\n      dataPt.y,\n      maxDistPx,\n      diskRadius\n    );\n\n    let bestIndex = -1;\n    let bestDistSq = Infinity;\n\n    // Inline the Poincaré projection math to avoid per-candidate object allocations.\n    // This mirrors `projectPoincare()` + `mobiusTransform()` clamping behavior.\n    const ax = view.ax;\n    const ay = view.ay;\n\n    // Avoid building a candidates array; iterate overlapping cells directly.\n    idx.forEachInAABB(\n      dataPt.x - queryRadius,\n      dataPt.y - queryRadius,\n      dataPt.x + queryRadius,\n      dataPt.y + queryRadius,\n      (i) => {\n        const dataX = ds.positions[i * 2];\n        const dataY = ds.positions[i * 2 + 1];\n\n        // mobiusTransform(z) = (z - a) / (1 - conj(a) * z)\n        const numX = dataX - ax;\n        const numY = dataY - ay;\n        const denomX = 1.0 - (ax * dataX + ay * dataY);\n        const denomY = -(ax * dataY - ay * dataX);\n        const denomNormSq = denomX * denomX + denomY * denomY;\n\n        let wx = 0.0;\n        let wy = 0.0;\n\n        if (denomNormSq < 1e-12) {\n          const norm = Math.sqrt(numX * numX + numY * numY);\n          if (norm < 1e-12) {\n            wx = 0.0;\n            wy = 0.0;\n          } else {\n            wx = (numX / norm) * 0.999;\n            wy = (numY / norm) * 0.999;\n          }\n        } else {\n          wx = (numX * denomX + numY * denomY) / denomNormSq;\n          wy = (numY * denomX - numX * denomY) / denomNormSq;\n          const rSq = wx * wx + wy * wy;\n          if (rSq >= 1.0) {\n            const r = Math.sqrt(rSq);\n            wx = (wx / r) * 0.999;\n            wy = (wy / r) * 0.999;\n          }\n        }\n\n        const sx = centerX + wx * diskRadius;\n        const sy = centerY - wy * diskRadius;\n\n        const dxDisk = sx - centerX;\n        const dyDisk = sy - centerY;\n        if (dxDisk * dxDisk + dyDisk * dyDisk > diskR2) return;\n\n        const dx = sx - screenX;\n        const dy = sy - screenY;\n        const distSq = dx * dx + dy * dy;\n\n        if (distSq <= maxDistSq) {\n          if (distSq < bestDistSq || (distSq === bestDistSq && i < bestIndex)) {\n            bestDistSq = distSq;\n            bestIndex = i;\n          }\n        }\n      },\n    );\n\n    if (bestIndex < 0) return null;\n\n    const bx = ds.positions[bestIndex * 2];\n    const by = ds.positions[bestIndex * 2 + 1];\n\n    // Recompute best screen position (single point) without allocations.\n    const bNumX = bx - ax;\n    const bNumY = by - ay;\n    const bDenomX = 1.0 - (ax * bx + ay * by);\n    const bDenomY = -(ax * by - ay * bx);\n    const bDenomNormSq = bDenomX * bDenomX + bDenomY * bDenomY;\n\n    let bwx = 0.0;\n    let bwy = 0.0;\n    if (bDenomNormSq < 1e-12) {\n      const norm = Math.sqrt(bNumX * bNumX + bNumY * bNumY);\n      if (norm < 1e-12) {\n        bwx = 0.0;\n        bwy = 0.0;\n      } else {\n        bwx = (bNumX / norm) * 0.999;\n        bwy = (bNumY / norm) * 0.999;\n      }\n    } else {\n      bwx = (bNumX * bDenomX + bNumY * bDenomY) / bDenomNormSq;\n      bwy = (bNumY * bDenomX - bNumX * bDenomY) / bDenomNormSq;\n      const rSq = bwx * bwx + bwy * bwy;\n      if (rSq >= 1.0) {\n        const r = Math.sqrt(rSq);\n        bwx = (bwx / r) * 0.999;\n        bwy = (bwy / r) * 0.999;\n      }\n    }\n\n    const bestScreenX = centerX + bwx * diskRadius;\n    const bestScreenY = centerY - bwy * diskRadius;\n\n    return {\n      index: bestIndex,\n      screenX: bestScreenX,\n      screenY: bestScreenY,\n      distance: Math.sqrt(bestDistSq),\n    };\n  }\n\n  lassoSelect(polyline: Float32Array): SelectionResult {\n    const ds = this.dataset;\n    const idx = this.dataIndex;\n    if (!ds || !idx) return createIndicesSelectionResult(new Set(), 0);\n\n    const startTime = performance.now();\n\n    // Always return geometry (Embedding Atlas style). The UI/benchmarks should\n    // use Renderer.countSelection(...) to obtain counts efficiently.\n\n    const dataPolyline = new Float32Array(polyline.length);\n    for (let i = 0; i < polyline.length / 2; i++) {\n      const sx = polyline[i * 2];\n      const sy = polyline[i * 2 + 1];\n      const data = unprojectPoincare(sx, sy, this.view, this.width, this.height);\n      dataPolyline[i * 2] = data.x;\n      dataPolyline[i * 2 + 1] = data.y;\n    }\n\n    // Tight AABB for fast reject in has() and efficient indexed counting.\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < dataPolyline.length; i += 2) {\n      const x = dataPolyline[i];\n      const y = dataPolyline[i + 1];\n      if (x < minX) minX = x;\n      if (x > maxX) maxX = x;\n      if (y < minY) minY = y;\n      if (y > maxY) maxY = y;\n    }\n\n    const bounds = { xMin: minX, yMin: minY, xMax: maxX, yMax: maxY };\n    const geometry: SelectionGeometry = { type: 'polygon', coords: dataPolyline, bounds };\n    const computeTimeMs = performance.now() - startTime;\n    return createGeometrySelectionResult(\n      geometry,\n      ds.positions,\n      computeTimeMs,\n      (px, py, polygon) => {\n        if (px < bounds.xMin || px > bounds.xMax || py < bounds.yMin || py > bounds.yMax) return false;\n        return pointInPolygon(px, py, polygon);\n      }\n    );\n  }\n\n  projectToScreen(dataX: number, dataY: number): { x: number; y: number } {\n    return projectPoincare(dataX, dataY, this.view, this.width, this.height);\n  }\n\n  unprojectFromScreen(screenX: number, screenY: number): { x: number; y: number } {\n    return unprojectPoincare(screenX, screenY, this.view, this.width, this.height);\n  }\n}\n","/**\n * Lasso polygon simplification utilities.\n *\n * These are UI-level helpers (not benchmark-critical math) and are intended to\n * match the \"feel\" of Embedding Atlas' lasso:\n * - sample points while dragging\n * - smooth (Chaikin)\n * - simplify until under vertex budget\n */\n\nfunction boundingRectXY(points: ArrayLike<number>): { xMin: number; yMin: number; xMax: number; yMax: number } {\n  let xMin = Infinity;\n  let yMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  for (let i = 0; i < points.length; i += 2) {\n    const x = points[i];\n    const y = points[i + 1];\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  }\n  if (!Number.isFinite(xMin) || !Number.isFinite(yMin)) {\n    return { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };\n  }\n  return { xMin, yMin, xMax, yMax };\n}\n\nfunction chaikinClosedXY(points: ArrayLike<number>, iterations: number): number[] {\n  // Chaikin smoothing on a closed polygon.\n  let pts = Array.from(points);\n  let n = Math.floor(pts.length / 2);\n  if (n < 3) return pts;\n\n  for (let it = 0; it < iterations; it++) {\n    n = Math.floor(pts.length / 2);\n    if (n < 3) break;\n    const out: number[] = new Array(n * 4);\n    let w = 0;\n    for (let i = 0; i < n; i++) {\n      const i0 = i;\n      const i1 = (i + 1) % n;\n      const x0 = pts[i0 * 2];\n      const y0 = pts[i0 * 2 + 1];\n      const x1 = pts[i1 * 2];\n      const y1 = pts[i1 * 2 + 1];\n\n      // Q = 0.75*p0 + 0.25*p1\n      out[w++] = 0.75 * x0 + 0.25 * x1;\n      out[w++] = 0.75 * y0 + 0.25 * y1;\n      // R = 0.25*p0 + 0.75*p1\n      out[w++] = 0.25 * x0 + 0.75 * x1;\n      out[w++] = 0.25 * y0 + 0.75 * y1;\n    }\n    pts = out;\n  }\n\n  return pts;\n}\n\n/**\n * Simplify a closed polygon represented as an interleaved XY list.\n *\n * Returns a new `Float32Array` of interleaved XY coordinates.\n */\nexport function simplifyPolygonData(points: ArrayLike<number>, maxVerts: number): Float32Array {\n  // Embedding Atlas strategy (ported conceptually):\n  // 1) Chaikin smoothing on the closed polygon.\n  // 2) Simplify with a tolerance derived from bounding box; increase until within budget.\n  const n0 = Math.floor(points.length / 2);\n  if (n0 <= maxVerts) return new Float32Array(points as any);\n\n  // Safety: avoid pathological blow-ups if the user drags for a long time.\n  // If we have too many points, pre-subsample before smoothing.\n  const MAX_RAW = 2048;\n  let base: ArrayLike<number> = points;\n  if (n0 > MAX_RAW) {\n    const out = new Float32Array(MAX_RAW * 2);\n    for (let i = 0; i < MAX_RAW; i++) {\n      const src = Math.floor((i * n0) / MAX_RAW);\n      out[i * 2] = points[src * 2];\n      out[i * 2 + 1] = points[src * 2 + 1];\n    }\n    base = out;\n  }\n\n  const smoothed = chaikinClosedXY(base, 5);\n  const rect = boundingRectXY(smoothed);\n  const span = Math.max(rect.xMax - rect.xMin, rect.yMax - rect.yMin);\n\n  const distSqToSegment = (px: number, py: number, ax: number, ay: number, bx: number, by: number): number => {\n    const abx = bx - ax;\n    const aby = by - ay;\n    const apx = px - ax;\n    const apy = py - ay;\n    const abLenSq = abx * abx + aby * aby;\n    let t = 0;\n    if (abLenSq > 1e-12) {\n      t = (apx * abx + apy * aby) / abLenSq;\n      if (t < 0) t = 0;\n      else if (t > 1) t = 1;\n    }\n    const qx = ax + t * abx;\n    const qy = ay + t * aby;\n    const dx = px - qx;\n    const dy = py - qy;\n    return dx * dx + dy * dy;\n  };\n\n  const rdp = (eps: number): number[] => {\n    const m = Math.floor(smoothed.length / 2);\n    if (m <= 2) return smoothed.slice();\n\n    const epsSq = eps * eps;\n    const keep = new Uint8Array(m);\n    keep[0] = 1;\n    keep[m - 1] = 1;\n\n    const stack: number[] = [0, m - 1];\n    while (stack.length > 0) {\n      const end = stack.pop()!;\n      const start = stack.pop()!;\n\n      const ax = smoothed[start * 2];\n      const ay = smoothed[start * 2 + 1];\n      const bx = smoothed[end * 2];\n      const by = smoothed[end * 2 + 1];\n\n      let maxD = -1;\n      let maxI = -1;\n      for (let i = start + 1; i < end; i++) {\n        const px = smoothed[i * 2];\n        const py = smoothed[i * 2 + 1];\n        const d = distSqToSegment(px, py, ax, ay, bx, by);\n        if (d > maxD) {\n          maxD = d;\n          maxI = i;\n        }\n      }\n\n      if (maxD > epsSq && maxI >= 0) {\n        keep[maxI] = 1;\n        stack.push(start, maxI);\n        stack.push(maxI, end);\n      }\n    }\n\n    const out: number[] = [];\n    for (let i = 0; i < m; i++) {\n      if (!keep[i]) continue;\n      out.push(smoothed[i * 2], smoothed[i * 2 + 1]);\n    }\n    return out;\n  };\n\n  // Match Embedding Atlas: start with tolerance ~= bbox/100, then increase slowly.\n  let tol = Math.max(1e-12, span / 100);\n  let simplified = rdp(tol);\n  let it = 0;\n  while (Math.floor(simplified.length / 2) > maxVerts && it < 20) {\n    tol *= 1.1;\n    simplified = rdp(tol);\n    it++;\n  }\n\n  // Final safety: if still too large, fall back to uniform subsampling.\n  const n = Math.floor(simplified.length / 2);\n  if (n > maxVerts) {\n    const out = new Float32Array(maxVerts * 2);\n    for (let i = 0; i < maxVerts; i++) {\n      const src = Math.floor((i * n) / maxVerts);\n      out[i * 2] = simplified[src * 2];\n      out[i * 2 + 1] = simplified[src * 2 + 1];\n    }\n    return out;\n  }\n\n  return new Float32Array(simplified);\n}\n","/**\n * Demo application for the viz-lab.\n * Provides interactive UI for testing reference implementations.\n */\n\nimport { Dataset, GeometryMode, Renderer, InteractionMode, Modifiers, SelectionResult } from '../core/types.js';\nimport { generateDataset, type DatasetDistribution } from '../core/dataset.js';\nimport { EuclideanReference } from '../impl_reference/euclidean_reference.js';\nimport { HyperbolicReference } from '../impl_reference/hyperbolic_reference.js';\nimport { EuclideanWebGLCandidate, HyperbolicWebGLCandidate } from '../impl_candidate/webgl_candidate.js';\nimport { simplifyPolygonData } from '../core/lasso_simplify.js';\n\ntype RendererType = 'webgl' | 'reference';\n\n// DOM elements\nlet canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst overlayCanvas = document.getElementById('overlayCanvas') as HTMLCanvasElement;\nconst canvasBody = document.getElementById('canvasBody') as HTMLDivElement;\nconst canvasHeader = document.getElementById('canvasHeader') as HTMLSpanElement;\nconst rendererInputs = Array.from(document.querySelectorAll<HTMLInputElement>('input[name=\"renderer\"]'));\nconst geometryInputs = Array.from(document.querySelectorAll<HTMLInputElement>('input[name=\"geometry\"]'));\nconst numPointsInput = document.getElementById('numPoints') as HTMLInputElement;\nconst numPointsLabel = document.getElementById('numPointsLabel') as HTMLSpanElement;\nconst datasetModeSelect = document.getElementById('datasetMode') as HTMLSelectElement;\nconst labelCountInput = document.getElementById('labelCount') as HTMLInputElement;\nconst labelCountLabel = document.getElementById('labelCountLabel') as HTMLSpanElement | null;\nconst seedInput = document.getElementById('seed') as HTMLInputElement;\nconst modeIndicator = document.getElementById('modeIndicator') as HTMLSpanElement;\n\n// Stats elements\nconst statPoints = document.getElementById('statPoints') as HTMLSpanElement;\nconst statSelected = document.getElementById('statSelected') as HTMLSpanElement;\nconst statHovered = document.getElementById('statHovered') as HTMLSpanElement;\nconst statFrameTime = document.getElementById('statFrameTime') as HTMLSpanElement;\nconst statLassoTime = document.getElementById('statLassoTime') as HTMLSpanElement;\n\n// State\nlet renderer: Renderer | null = null;\nlet dataset: Dataset | null = null;\nlet lastDatasetKey = '';\nlet currentGeometry: GeometryMode = 'euclidean';\nlet currentRendererType: RendererType = 'webgl';\nlet mode: InteractionMode = 'pan';\n\nconst POINT_PRESETS = [\n  1_000,\n  10_000,\n  50_000,\n  100_000,\n  250_000,\n  500_000,\n  1_000_000,\n  2_000_000,\n  5_000_000,\n  10_000_000,\n  20_000_000,\n];\n\n// Interaction state\nlet isDragging = false;\nlet isLassoing = false;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\n\n// Lasso UX notes (Embedding Atlas style):\n// - Gesture: Shift + Meta/Ctrl drag (momentary) starts lasso.\n// - Lasso vertices are simplified continuously while dragging.\n// - The lasso overlay persists after mouse-up until explicitly cleared.\n// - The persistent overlay is stored in DATA SPACE so it tracks pan/zoom.\nconst LASSO_MAX_VERTS_INTERACTION = 24;\nconst LASSO_MAX_VERTS_FINAL = 24;\nconst LASSO_MIN_SAMPLE_DIST_PX = 2.0;\n\n// Raw sampled lasso points in DATA SPACE (interleaved x,y).\n// We sample in data space (Embedding Atlas style) so simplification is\n// view-invariant and avoids screen-space artifacts.\nlet lassoRawDataPoints: number[] = [];\n\n// Current simplified lasso polygon in DATA SPACE (interleaved x,y).\nlet lassoActiveDataPolygon: Float32Array | null = null;\n\n// For sampling thresholding (screen space).\nlet lassoLastScreenX = 0;\nlet lassoLastScreenY = 0;\nlet lassoDirty = false;\n\n// Persisted range selection (data-space polygon: interleaved x,y).\nlet rangeSelectionDataPolygon: Float32Array | null = null;\n\nfunction projectDataPolygonToScreen(polyData: Float32Array): Float32Array {\n  if (!renderer) return polyData;\n  const n = polyData.length / 2;\n  const out = new Float32Array(polyData.length);\n  for (let i = 0; i < n; i++) {\n    const x = polyData[i * 2];\n    const y = polyData[i * 2 + 1];\n    const s = renderer.projectToScreen(x, y);\n    out[i * 2] = s.x;\n    out[i * 2 + 1] = s.y;\n  }\n  return out;\n}\n\n// Cancel token for async selection materialization.\nlet selectionJobId = 0;\n\nasync function countSelectionAsync(\n  jobId: number,\n  result: SelectionResult,\n): Promise<void> {\n  if (!renderer) return;\n\n  const total = await renderer.countSelection(result, {\n    shouldCancel: () => jobId !== selectionJobId,\n    onProgress: (selectedCount) => {\n      if (jobId !== selectionJobId) return;\n      statSelected.textContent = `${selectedCount.toLocaleString()} (computing…)`;\n    },\n    yieldEveryMs: 8,\n  });\n\n  if (jobId !== selectionJobId) return;\n  statSelected.textContent = total.toLocaleString();\n}\n\n// Frame scheduling + throttling\nlet rafPending = false;\nlet needsRender = false;\nlet lastRafTs = 0;\n\n// Coalesced interaction work (apply at most once per frame)\nlet pendingPanDx = 0;\nlet pendingPanDy = 0;\nlet pendingModifiers: Modifiers = { shift: false, ctrl: false, alt: false, meta: false };\n\nlet pendingHoverX = 0;\nlet pendingHoverY = 0;\nlet hoverDirty = false;\n\n// Performance tracking\nlet frameCount = 0;\nconst frameTimes: number[] = [];\nconst frameIntervals: number[] = [];\n\n// Debug/automation hook (used by demo interaction benchmark)\ndeclare global {\n  interface Window {\n    __vizDemo?: {\n      getRenderer: () => Renderer | null;\n      getView: () => any;\n      getCanvasSize: () => { cssWidth: number; cssHeight: number; bufferWidth: number; bufferHeight: number };\n    };\n  }\n}\n\nwindow.__vizDemo = {\n  getRenderer: () => renderer,\n  getView: () => renderer ? renderer.getView() : null,\n  getCanvasSize: () => ({\n    cssWidth: canvas.clientWidth,\n    cssHeight: canvas.clientHeight,\n    bufferWidth: canvas.width,\n    bufferHeight: canvas.height,\n  }),\n};\n\n/**\n * Replace the canvas element to reset context.\n * A canvas can only have one context type (WebGL or 2D), so we need a fresh canvas when switching.\n */\nfunction replaceCanvas(): HTMLCanvasElement {\n  const newCanvas = document.createElement('canvas');\n  newCanvas.id = 'canvas';\n  canvas.replaceWith(newCanvas);\n  canvas = newCanvas;\n\n  // Re-attach event listeners to new canvas\n  canvas.addEventListener('mousedown', handleMouseDown);\n  canvas.addEventListener('mousemove', handleMouseMove);\n  canvas.addEventListener('mouseup', handleMouseUp);\n  canvas.addEventListener('mouseleave', handleMouseUp);\n  canvas.addEventListener('wheel', handleWheel, { passive: false });\n  canvas.addEventListener('dblclick', handleDoubleClick);\n\n  return newCanvas;\n}\n\n/**\n * Read theme-aware visualization colors from CSS custom properties.\n */\nfunction getVizThemeColors(): {\n  backgroundColor: string;\n  diskFillColor: string;\n  diskBorderColor: string;\n  gridColor: string;\n} {\n  const styles = getComputedStyle(document.documentElement);\n  const pick = (name: string, fallback: string) => {\n    const value = styles.getPropertyValue(name).trim();\n    return value || fallback;\n  };\n\n  return {\n    backgroundColor: pick('--viz-bg', '#13171f'),\n    diskFillColor: pick('--viz-disk', '#1b2230'),\n    diskBorderColor: pick('--viz-border', '#6b7280'),\n    gridColor: pick('--viz-grid', '#2b334266'),\n  };\n}\n\n/**\n * Initialize the renderer based on geometry and renderer type.\n */\nfunction initRenderer(geometry: GeometryMode, rendererType: RendererType): void {\n  if (renderer) {\n    renderer.destroy();\n  }\n\n  // Replace canvas when switching between WebGL and 2D contexts\n  // A canvas can only have one context type\n  const needsNewCanvas = currentRendererType !== rendererType ||\n    (rendererType === 'webgl' && !canvas.getContext('webgl2')) ||\n    (rendererType === 'reference' && !canvas.getContext('2d'));\n\n  if (needsNewCanvas) {\n    replaceCanvas();\n  }\n\n  const rect = canvasBody.getBoundingClientRect();\n  const width = Math.floor(rect.width);\n  const height = Math.floor(rect.height);\n\n  // Keep overlay canvas in sync regardless of renderer type.\n  resizeOverlay(width, height);\n\n  if (rendererType === 'webgl') {\n    if (geometry === 'euclidean') {\n      renderer = new EuclideanWebGLCandidate();\n    } else {\n      renderer = new HyperbolicWebGLCandidate();\n    }\n    canvasHeader.textContent = 'WebGL';\n  } else {\n    if (geometry === 'euclidean') {\n      renderer = new EuclideanReference();\n    } else {\n      renderer = new HyperbolicReference();\n    }\n    canvasHeader.textContent = 'Reference';\n  }\n\n  const theme = getVizThemeColors();\n  renderer.init(canvas, {\n    width,\n    height,\n    devicePixelRatio: window.devicePixelRatio,\n    backgroundColor: theme.backgroundColor,\n    poincareDiskFillColor: theme.diskFillColor,\n    poincareDiskBorderColor: theme.diskBorderColor,\n    poincareGridColor: theme.gridColor,\n  });\n\n  currentGeometry = geometry;\n  currentRendererType = rendererType;\n}\n\nfunction resizeOverlay(width: number, height: number): void {\n  // Overlay is UI-only (lasso). Keep it at DPR=1 for performance.\n  // Clearing/drawing a DPR=2 overlay every frame can noticeably hurt FPS.\n  const dpr = 1;\n  overlayCanvas.width = Math.max(1, Math.floor(width * dpr));\n  overlayCanvas.height = Math.max(1, Math.floor(height * dpr));\n  overlayCanvas.style.width = `${width}px`;\n  overlayCanvas.style.height = `${height}px`;\n\n  const ctx = overlayCanvas.getContext('2d');\n  if (!ctx) return;\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.clearRect(0, 0, width, height);\n}\n\nfunction getSelectedGeometry(): GeometryMode {\n  const el = document.querySelector<HTMLInputElement>('input[name=\"geometry\"]:checked');\n  return (el?.value as GeometryMode) ?? 'euclidean';\n}\n\nfunction getSelectedRendererType(): RendererType {\n  const el = document.querySelector<HTMLInputElement>('input[name=\"renderer\"]:checked');\n  return (el?.value as RendererType) ?? 'webgl';\n}\n\nfunction getSelectedDatasetDistribution(): DatasetDistribution {\n  return (datasetModeSelect?.value as DatasetDistribution) ?? 'default';\n}\n\nfunction formatCount(n: number): string {\n  if (n >= 1_000_000) return `${n / 1_000_000}M`;\n  if (n >= 1_000) return `${n / 1_000}K`;\n  return `${n}`;\n}\n\nfunction getPointCount(): number {\n  const i = Math.max(0, Math.min(POINT_PRESETS.length - 1, parseInt(numPointsInput.value, 10) || 0));\n  return POINT_PRESETS[i];\n}\n\nfunction syncPointLabel(): void {\n  numPointsLabel.textContent = formatCount(getPointCount());\n}\n\nlet generateTimer: number | null = null;\nfunction scheduleGenerateAndLoad(): void {\n  if (generateTimer !== null) window.clearTimeout(generateTimer);\n  generateTimer = window.setTimeout(() => {\n    generateTimer = null;\n    generateAndLoad();\n  }, 150);\n}\n\n/**\n * Generate and load a new dataset.\n */\nfunction generateAndLoad(): void {\n  const rendererType = getSelectedRendererType();\n  const geometry = getSelectedGeometry();\n  const n = getPointCount();\n  const labelCount = parseInt(labelCountInput.value, 10);\n  const seed = parseInt(seedInput.value, 10);\n  const distribution = getSelectedDatasetDistribution();\n\n  const datasetKey = `${geometry}/${distribution}/${n}/${labelCount}/${seed}`;\n  const needsNewDataset = !dataset || datasetKey !== lastDatasetKey;\n\n  // Cancel any in-flight selection job.\n  selectionJobId++;\n\n  // Initialize renderer if needed (geometry or renderer type changed)\n  if (currentGeometry !== geometry || currentRendererType !== rendererType || !renderer) {\n    initRenderer(geometry, rendererType);\n  }\n\n  // Generate dataset only if inputs changed.\n  if (needsNewDataset) {\n    dataset = generateDataset({\n      seed,\n      n,\n      labelCount,\n      geometry,\n      distribution,\n    });\n    lastDatasetKey = datasetKey;\n  }\n\n  // Load dataset\n  renderer!.setDataset(dataset!);\n\n  // Update stats\n  statPoints.textContent = n.toLocaleString();\n  statSelected.textContent = '0';\n  statHovered.textContent = '-';\n  statFrameTime.textContent = '—';\n  statFrameTime.style.color = '';\n  statLassoTime.textContent = '—';\n  frameTimes.length = 0; // Reset frame time tracking\n  frameIntervals.length = 0;\n  lastRafTs = 0;\n\n  // Clear overlay UI.\n  {\n    overlayCanvas.style.display = 'none';\n    const ctx = overlayCanvas.getContext('2d');\n    if (ctx) {\n      const rect = canvasBody.getBoundingClientRect();\n      ctx.clearRect(0, 0, rect.width, rect.height);\n    }\n  }\n\n  // Render\n  requestRender();\n}\n\n/**\n * Request a render frame.\n */\nfunction requestRender(): void {\n  needsRender = true;\n  if (rafPending) return;\n  rafPending = true;\n  requestAnimationFrame(tick);\n}\n\nfunction tick(ts: number): void {\n  rafPending = false;\n\n  // Track actual frame interval (what people perceive as FPS).\n  if (lastRafTs !== 0) {\n    frameIntervals.push(ts - lastRafTs);\n    if (frameIntervals.length > 60) frameIntervals.shift();\n  }\n  lastRafTs = ts;\n\n  if (needsRender) {\n    needsRender = false;\n    render();\n  }\n\n  // Keep animating during interaction so motion stays smooth even if input\n  // events arrive irregularly.\n  if (isDragging || isLassoing || hoverDirty) {\n    requestRender();\n  }\n}\n\n/**\n * Render the current frame.\n */\nfunction render(): void {\n  if (!renderer) return;\n\n  // Apply coalesced pan at most once per frame.\n  // Important: apply even if the drag ended before this frame executed.\n  if (renderer && (pendingPanDx !== 0 || pendingPanDy !== 0)) {\n    renderer.pan(pendingPanDx, pendingPanDy, pendingModifiers);\n    pendingPanDx = 0;\n    pendingPanDy = 0;\n  }\n\n  // Throttle hover hit-test to once per frame.\n  if (!isDragging && !isLassoing && hoverDirty && renderer) {\n    const hit = renderer.hitTest(pendingHoverX, pendingHoverY);\n    if (hit) {\n      renderer.setHovered(hit.index);\n      statHovered.textContent = `#${hit.index}`;\n    } else {\n      renderer.setHovered(-1);\n      statHovered.textContent = '-';\n    }\n    hoverDirty = false;\n  }\n\n  const startTime = performance.now();\n  renderer.render();\n  const endTime = performance.now();\n\n  // Track frame time\n  const frameTime = endTime - startTime;\n  frameTimes.push(frameTime);\n  if (frameTimes.length > 60) frameTimes.shift();\n\n  // Update frame time display (every 10 frames)\n  frameCount++;\n  if (frameCount % 10 === 0) {\n    const avgCpuMs = frameTimes.reduce((a, b) => a + b, 0) / Math.max(1, frameTimes.length);\n    const avgIntervalMs = frameIntervals.reduce((a, b) => a + b, 0) / Math.max(1, frameIntervals.length);\n    const fps = avgIntervalMs > 1e-6 ? (1000 / avgIntervalMs) : 0;\n    statFrameTime.textContent = `fps ${fps.toFixed(1)} · cpu ${avgCpuMs.toFixed(2)}ms`;\n    statFrameTime.style.color = fps >= 50 ? '#8b8' : '#b66';\n  }\n\n  // Draw lasso only while actively drawing.\n  if (isLassoing) {\n    // Continuously simplify while dragging to keep overlay + selection snappy.\n    // (Embedding Atlas uses simplifyPolygon(points, 24).)\n    if (lassoDirty) {\n      lassoDirty = false;\n      if (lassoRawDataPoints.length >= 6) {\n        lassoActiveDataPolygon = simplifyPolygonData(lassoRawDataPoints, LASSO_MAX_VERTS_INTERACTION);\n      } else {\n        lassoActiveDataPolygon = null;\n      }\n    }\n  }\n\n  // Overlay rendering is UI-only; keep it decoupled from WebGL.\n  // - While dragging, draw the (simplified) in-progress lasso in screen space.\n  // - When not dragging, draw the persisted lasso projected from data space.\n  if (isLassoing && lassoActiveDataPolygon && lassoActiveDataPolygon.length >= 6) {\n    drawLassoData(lassoActiveDataPolygon);\n  } else if (rangeSelectionDataPolygon && rangeSelectionDataPolygon.length >= 6) {\n    drawLassoData(rangeSelectionDataPolygon);\n  } else {\n    // Nothing to show.\n    overlayCanvas.style.display = 'none';\n    const ctx = overlayCanvas.getContext('2d');\n    if (ctx) ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);\n  }\n}\n\n/**\n * Draw a lasso polygon given in SCREEN SPACE (interleaved x,y).\n */\nfunction drawLassoScreen(polyline: Float32Array): void {\n  overlayCanvas.style.display = 'block';\n  const ctx = overlayCanvas.getContext('2d');\n  if (!ctx) return;\n\n  const width = overlayCanvas.width;\n  const height = overlayCanvas.height;\n  ctx.clearRect(0, 0, width, height);\n\n  if (polyline.length < 6) return;\n\n  ctx.strokeStyle = '#cccccc';\n  ctx.lineWidth = 2;\n  ctx.setLineDash([5, 5]);\n  ctx.beginPath();\n  ctx.moveTo(polyline[0], polyline[1]);\n  for (let i = 2; i < polyline.length; i += 2) {\n    ctx.lineTo(polyline[i], polyline[i + 1]);\n  }\n  ctx.closePath();\n  ctx.stroke();\n\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.06)';\n  ctx.fill();\n}\n\n/**\n * Draw a lasso polygon given in DATA SPACE (interleaved x,y).\n * The overlay is projected each frame so it tracks pan/zoom correctly.\n */\nfunction drawLassoData(polygonData: Float32Array): void {\n  if (!renderer) return;\n\n  const n = polygonData.length / 2;\n  if (n < 3) return;\n\n  drawLassoScreen(projectDataPolygonToScreen(polygonData));\n}\n\n/**\n * Update the mode indicator.\n */\nfunction updateModeIndicator(): void {\n  modeIndicator.textContent = mode.toUpperCase();\n  modeIndicator.className = `mode ${mode}`;\n}\n\n// === Event Handlers ===\n\nfunction handleMouseDown(e: MouseEvent): void {\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n\n  lastMouseX = x;\n  lastMouseY = y;\n\n  // Embedding Atlas gesture:\n  // - momentary lasso: Shift + Meta (Cmd on macOS) or Shift + Ctrl\n  const wantsLasso = e.shiftKey && (e.metaKey || e.ctrlKey);\n\n  // Plain click clears the persistent range selection (lasso overlay).\n  // This matches the Embedding Atlas behavior: rangeSelection persists until cleared.\n  // NOTE: We only clear range selection here; point selection is preserved.\n  if (!wantsLasso && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && rangeSelectionDataPolygon) {\n    rangeSelectionDataPolygon = null;\n    // Cancel any in-flight selection materialization since the predicate changed.\n    selectionJobId++;\n    requestRender();\n  }\n\n  if (wantsLasso) {\n    if (!renderer) return;\n    mode = 'lasso';\n    isLassoing = true;\n    overlayCanvas.style.display = 'block';\n    const d0 = renderer.unprojectFromScreen(x, y);\n    lassoRawDataPoints = [d0.x, d0.y];\n    lassoActiveDataPolygon = null;\n    lassoLastScreenX = x;\n    lassoLastScreenY = y;\n    lassoDirty = true;\n    statSelected.textContent = '0';\n    updateModeIndicator();\n    requestRender();\n  } else {\n    // Start pan\n    mode = 'pan';\n    isDragging = true;\n    updateModeIndicator();\n\n    pendingPanDx = 0;\n    pendingPanDy = 0;\n    pendingModifiers = {\n      shift: e.shiftKey,\n      ctrl: e.ctrlKey,\n      alt: e.altKey,\n      meta: e.metaKey,\n    };\n\n    // For hyperbolic, notify start of pan\n    if (renderer && 'startPan' in renderer) {\n      (renderer as any).startPan(x, y);\n    }\n\n    requestRender();\n  }\n}\n\nfunction handleMouseMove(e: MouseEvent): void {\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n\n  if (isDragging && renderer) {\n    const deltaX = x - lastMouseX;\n    const deltaY = y - lastMouseY;\n    pendingPanDx += deltaX;\n    pendingPanDy += deltaY;\n    pendingModifiers = {\n      shift: e.shiftKey,\n      ctrl: e.ctrlKey,\n      alt: e.altKey,\n      meta: e.metaKey,\n    };\n    lastMouseX = x;\n    lastMouseY = y;\n    requestRender();\n  } else if (isLassoing) {\n    // Avoid capturing every single mousemove event (can be thousands of vertices).\n    // Sample only when we moved enough in screen space.\n    const dx = x - lassoLastScreenX;\n    const dy = y - lassoLastScreenY;\n    if (dx * dx + dy * dy >= LASSO_MIN_SAMPLE_DIST_PX * LASSO_MIN_SAMPLE_DIST_PX) {\n      if (renderer) {\n        const d = renderer.unprojectFromScreen(x, y);\n        lassoRawDataPoints.push(d.x, d.y);\n        lassoDirty = true;\n      }\n      lassoLastScreenX = x;\n      lassoLastScreenY = y;\n    }\n    requestRender();\n  } else if (renderer) {\n    // Hover test (throttled to rAF)\n    pendingHoverX = x;\n    pendingHoverY = y;\n    hoverDirty = true;\n    requestRender();\n  }\n}\n\nfunction handleMouseUp(_e: MouseEvent): void {\n  // Flush any pending pan deltas *before* clearing state.\n  // Otherwise, releasing the mouse before the scheduled rAF frame runs can\n  // drop the final (or entire) pan and appear as if the view snaps back.\n  if (renderer && (pendingPanDx !== 0 || pendingPanDy !== 0)) {\n    renderer.pan(pendingPanDx, pendingPanDy, pendingModifiers);\n    pendingPanDx = 0;\n    pendingPanDy = 0;\n  }\n\n  if (isLassoing && renderer && lassoRawDataPoints.length >= 6) {\n    // Complete lasso selection.\n    const dataPoly = lassoActiveDataPolygon ?? simplifyPolygonData(lassoRawDataPoints, LASSO_MAX_VERTS_FINAL);\n    const screenPolyline = projectDataPolygonToScreen(dataPoly);\n    const result = renderer.lassoSelect(screenPolyline);\n\n    // Persist the range selection overlay in DATA SPACE (so it tracks pan/zoom).\n    rangeSelectionDataPolygon = dataPoly;\n\n    // Apply selection (Embedding Atlas style): keep only the range-selection\n    // overlay (no point highlighting) and compute an exact count asynchronously.\n    renderer.setSelection(new Set());\n    statSelected.textContent = '…';\n    const jobId = ++selectionJobId;\n    void countSelectionAsync(jobId, result);\n    statLassoTime.textContent = `${result.computeTimeMs.toFixed(2)}ms`;\n  }\n\n  isDragging = false;\n  isLassoing = false;\n  lassoRawDataPoints = [];\n  lassoActiveDataPolygon = null;\n  lassoDirty = false;\n  pendingPanDx = 0;\n  pendingPanDy = 0;\n  hoverDirty = false;\n\n  // If the renderer supports it, tell it the interaction is over so the next\n  // render uses the stable (non-interaction) policy immediately.\n  // This avoids a visible LOD \"pop\" when the next hover-triggered render would\n  // otherwise switch from interaction subsampling back to full detail.\n  if (renderer && 'endInteraction' in (renderer as any)) {\n    (renderer as any).endInteraction();\n  }\n\n  // Do NOT hide the overlay here: Embedding Atlas keeps range selection visible\n  // until explicitly cleared (plain click / dbl-click).\n  mode = 'pan';\n  updateModeIndicator();\n  requestRender();\n}\n\nfunction handleWheel(e: WheelEvent): void {\n  e.preventDefault();\n  if (!renderer) return;\n\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n\n  // Normalize wheel delta\n  const delta = -e.deltaY / 100;\n\n  renderer.zoom(x, y, delta, {\n    shift: e.shiftKey,\n    ctrl: e.ctrlKey,\n    alt: e.altKey,\n    meta: e.metaKey,\n  });\n\n  requestRender();\n}\n\nfunction handleDoubleClick(): void {\n  if (!renderer) return;\n\n  // Clear selection\n  selectionJobId++;\n  renderer.setSelection(new Set());\n  statSelected.textContent = '0';\n\n  // Hide overlay since range selection is cleared.\n  rangeSelectionDataPolygon = null;\n  overlayCanvas.style.display = 'none';\n  const ctx = overlayCanvas.getContext('2d');\n  if (ctx) ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);\n  requestRender();\n}\n\nfunction handleResize(): void {\n  if (!renderer) return;\n\n  const rect = canvasBody.getBoundingClientRect();\n  const width = Math.floor(rect.width);\n  const height = Math.floor(rect.height);\n\n  renderer.resize(width, height);\n  resizeOverlay(width, height);\n  requestRender();\n}\n\n// === Initialization ===\n\n// Set up event listeners\ncanvas.addEventListener('mousedown', handleMouseDown);\ncanvas.addEventListener('mousemove', handleMouseMove);\ncanvas.addEventListener('mouseup', handleMouseUp);\ncanvas.addEventListener('mouseleave', handleMouseUp);\ncanvas.addEventListener('wheel', handleWheel, { passive: false });\ncanvas.addEventListener('dblclick', handleDoubleClick);\nwindow.addEventListener('resize', handleResize);\n\nfor (const el of geometryInputs) el.addEventListener('change', scheduleGenerateAndLoad);\nfor (const el of rendererInputs) el.addEventListener('change', scheduleGenerateAndLoad);\ndatasetModeSelect.addEventListener('change', scheduleGenerateAndLoad);\nnumPointsInput.addEventListener('input', () => {\n  syncPointLabel();\n  scheduleGenerateAndLoad();\n});\nnumPointsInput.addEventListener('change', () => {\n  syncPointLabel();\n  scheduleGenerateAndLoad();\n});\nlabelCountInput.addEventListener('input', () => {\n  if (labelCountLabel) labelCountLabel.textContent = labelCountInput.value;\n  scheduleGenerateAndLoad();\n});\nlabelCountInput.addEventListener('change', () => {\n  if (labelCountLabel) labelCountLabel.textContent = labelCountInput.value;\n  scheduleGenerateAndLoad();\n});\nseedInput.addEventListener('change', scheduleGenerateAndLoad);\n\n// Re-init renderer when color scheme changes\nwindow.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {\n  if (renderer) {\n    initRenderer(currentGeometry, currentRendererType);\n    if (dataset) renderer.setDataset(dataset);\n    requestRender();\n  }\n});\n\n// Initial generation\nsyncPointLabel();\nif (labelCountLabel) labelCountLabel.textContent = labelCountInput.value;\ngenerateAndLoad();\n\nconsole.log('Viz Lab initialized');\n"],"names":["SeededRNG","seed","__publicField","s","z","result","t","min","max","mean","std","u1","u2","x","k","FAST_PATH_THRESHOLD_N","gaussianFastApprox","rng","fillPoincareClusterCentersRandom","labelCount","outCx","outCy","outJitterStd","label","r","theta","cx","cy","r2","generateDataset","config","positions","labels","fast","distribution","clusterCenters","i","center","noiseX","noiseY","jitterStd","j","y","rSq","invR","tableSize","cosTable","sinTable","DEFAULT_COLORS","SELECTION_COLOR","HOVER_COLOR","createIndicesSelectionResult","indices","computeTimeMs","index","createGeometrySelectionResult","geometry","pointInPolygonFn","createEuclideanView","projectEuclidean","dataX","dataY","view","width","height","scale","unprojectEuclidean","screenX","screenY","panEuclidean","deltaScreenX","deltaScreenY","zoomEuclidean","anchorScreenX","anchorScreenY","delta","anchorData","zoomFactor","newZoom","newScale","newCenterX","newCenterY","pointInPolygon","px","py","polygon","n","inside","xi","yi","xj","yj","isPointOnSegment","xIntersect","x1","y1","x2","y2","tolerance","minX","maxX","minY","maxY","dx","dy","lengthSq","projX","projY","lassoSelectBruteForce","EuclideanReference","canvas","opts","ctx","dataset","dataWidth","dataHeight","fitZoom","radius","screen","deltaX","deltaY","_modifiers","anchorX","anchorY","bestIndex","bestDistSq","maxDistSq","distSq","polyline","startTime","dataPolyline","data","_opts","createHyperbolicView","mobiusTransform","zx","zy","ax","ay","numX","numY","denomX","denomY","denomNormSq","norm","resultX","resultY","inverseMobiusTransform","wx","wy","projectPoincare","transformed","diskRadius","unprojectPoincare","diskX","diskY","clampedX","clampedY","solveForCamera","d2x","d2y","A","B","det","rhsX","rhsY","panPoincare","startScreenX","startScreenY","endScreenX","endScreenY","d1x","d1y","clampToDisk","maxR","d1","d2","p","newA","zoomPoincare","newDisplayZoom","dataPoint","diskRadiusNew","newScreenX","newScreenY","HyperbolicReference","centerX","centerY","numRadial","angle","numCircles","startX","startY","endX","endY","dxDisk","dyDisk","clampInt","v","lo","hi","clamp","computeBounds","eps","UniformGridIndex","bounds","targetPointsPerCell","spanX","spanY","totalCells","aspect","cellsX","cellsY","cellCount","counts","offsets","acc","c","cursor","ids","cell","dst","visit","cx0","cy0","cx1","cy1","rowBase","start","end","out","id","parseHexColor","color","hex","g","b","a","parseHexColorBytes","compileShader","gl","type","source","shader","info","linkProgram","vsSource","fsSource","vs","fs","program","setCanvasSize","dpr","FS_POINTS","FS_POINTS_SQUARE","FS_SOLID","VS_FULLSCREEN","FS_COMPOSITE","FS_POINCARE_DISK","VS_EUCLIDEAN","VS_POINCARE","WebGLRendererBase","disk","fill","border","grid","hasDiskFillOverride","pointCount","d","cssPixels","expectedDrawCount","pointsFboPixelBudget","dprFromPointsPixels","denom","dprFromFragments","cap","floor","chosen","target","step","drawCount","pointsDpr","estimatedFragments","on","off","nextDpr","rawSize","size","maxTex","texW","texH","capacity","o","upload","ds","idx","xMin","yMin","xMax","yMax","shouldCancel","onProgress","yieldEveryMs","selected","processed","CHECK_STRIDE","nextCheck","lastYieldTs","resolve","br","bg","bb","ba","w","h","status","desiredDpr","zoom","zoomSame","circleProgram","squareProgram","diskProgram","useFullUpload","count","subPos","subLab","MAX_RENDER_SELECTION","renderCount","pos","lab","isInteracting","hasLod","useInteractionLod","useLargeNLod","useLod","baseDrawCount","basePoints","ringRadius","fillRadius","circlePoints","EuclideanWebGLCandidate","cached","maxDistPx","dataRadius","maxDataDistSq","dataPt","cX","cY","dxData","dyData","sx","sy","bx","by","HyperbolicWebGLCandidate","a2","screenRadiusPx","aMag","C","denomX0","denomY0","D0","K","it","D","diskR2","dxCur","dyCur","maxCursorR","queryRadius","bNumX","bNumY","bDenomX","bDenomY","bDenomNormSq","bwx","bwy","bestScreenX","bestScreenY","boundingRectXY","points","chaikinClosedXY","iterations","pts","i0","i1","x0","y0","simplifyPolygonData","maxVerts","n0","MAX_RAW","base","src","smoothed","rect","span","distSqToSegment","abx","aby","apx","apy","abLenSq","qx","qy","rdp","m","epsSq","keep","stack","maxD","maxI","tol","simplified","overlayCanvas","canvasBody","canvasHeader","rendererInputs","geometryInputs","numPointsInput","numPointsLabel","datasetModeSelect","labelCountInput","labelCountLabel","seedInput","modeIndicator","statPoints","statSelected","statHovered","statFrameTime","statLassoTime","renderer","lastDatasetKey","currentGeometry","currentRendererType","mode","POINT_PRESETS","isDragging","isLassoing","lastMouseX","lastMouseY","LASSO_MAX_VERTS_INTERACTION","LASSO_MAX_VERTS_FINAL","LASSO_MIN_SAMPLE_DIST_PX","lassoRawDataPoints","lassoActiveDataPolygon","lassoLastScreenX","lassoLastScreenY","lassoDirty","rangeSelectionDataPolygon","projectDataPolygonToScreen","polyData","selectionJobId","countSelectionAsync","jobId","total","selectedCount","rafPending","needsRender","lastRafTs","pendingPanDx","pendingPanDy","pendingModifiers","pendingHoverX","pendingHoverY","hoverDirty","frameCount","frameTimes","frameIntervals","replaceCanvas","newCanvas","handleMouseDown","handleMouseMove","handleMouseUp","handleWheel","handleDoubleClick","getVizThemeColors","styles","pick","name","fallback","initRenderer","rendererType","resizeOverlay","theme","getSelectedGeometry","el","getSelectedRendererType","getSelectedDatasetDistribution","formatCount","getPointCount","syncPointLabel","generateTimer","scheduleGenerateAndLoad","generateAndLoad","datasetKey","needsNewDataset","requestRender","tick","ts","render","hit","frameTime","avgCpuMs","avgIntervalMs","fps","drawLassoData","drawLassoScreen","polygonData","updateModeIndicator","e","wantsLasso","d0","_e","dataPoly","screenPolyline","handleResize"],"mappings":"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"}